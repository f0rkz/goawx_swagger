
/*
 * Ansible Automation Platform controller API
 *
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * API version: 
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */

package swagger

import (
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
	"fmt"
	"github.com/antihax/optional"
)

// Linger please
var (
	_ context.Context
)

type WorkflowJobTemplatesApiService service

/*
WorkflowJobTemplatesApiService  List Users
 Make a GET request to this resource to retrieve the list of users.  The resulting data structure contains:      {         \&quot;count\&quot;: 99,         \&quot;next\&quot;: null,         \&quot;previous\&quot;: null,         \&quot;results\&quot;: [             ...         ]     }  The &#x60;count&#x60; field indicates the total number of users found for the given query.  The &#x60;next&#x60; and &#x60;previous&#x60; fields provides links to additional results if there are more than will fit on a single page.  The &#x60;results&#x60; list contains zero or more user records.    ## Results  Each user data structure includes the following fields:  * &#x60;id&#x60;: Database ID for this user. (integer) * &#x60;type&#x60;: Data type for this user. (choice) * &#x60;url&#x60;: URL for this user. (string) * &#x60;related&#x60;: Data structure with URLs of related resources. (object) * &#x60;summary_fields&#x60;: Data structure with name/description for related resources.  The output for some objects may be limited for performance reasons. (object) * &#x60;created&#x60;: Timestamp when this user was created. (datetime) * &#x60;modified&#x60;: Timestamp when this user was last modified. (datetime) * &#x60;username&#x60;: Required. 150 characters or fewer. Letters, digits and @/./+/-/_ only. (string) * &#x60;first_name&#x60;:  (string) * &#x60;last_name&#x60;:  (string) * &#x60;email&#x60;:  (string) * &#x60;is_superuser&#x60;: Designates that this user has all permissions without explicitly assigning them. (boolean) * &#x60;is_system_auditor&#x60;:  (boolean)  * &#x60;ldap_dn&#x60;:  (string) * &#x60;last_login&#x60;:  (datetime) * &#x60;external_account&#x60;: Set if the account is managed by an external service (field)    ## Sorting  To specify that users are returned in a particular order, use the &#x60;order_by&#x60; query string parameter on the GET request.      ?order_by&#x3D;username  Prefix the field name with a dash &#x60;-&#x60; to sort in reverse:      ?order_by&#x3D;-username  Multiple sorting fields may be specified by separating the field names with a comma &#x60;,&#x60;:      ?order_by&#x3D;username,some_other_field  ## Pagination  Use the &#x60;page_size&#x60; query string parameter to change the number of results returned for each request.  Use the &#x60;page&#x60; query string parameter to retrieve a particular page of results.      ?page_size&#x3D;100&amp;page&#x3D;2  The &#x60;previous&#x60; and &#x60;next&#x60; links returned with the results will set these query string parameters automatically.  ## Searching  Use the &#x60;search&#x60; query string parameter to perform a case-insensitive search within all designated text fields of a model.      ?search&#x3D;findme  (_Added in Ansible Tower 3.1.0_) Search across related fields:      ?related__search&#x3D;findme
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id 
 * @param optional nil or *WorkflowJobTemplatesApiWorkflowJobTemplatesWorkflowJobTemplatesAccessListListOpts - Optional Parameters:
     * @param "Page" (optional.Int32) -  A page number within the paginated result set.
     * @param "PageSize" (optional.Int32) -  Number of results to return per page.
     * @param "Search" (optional.String) -  A search term.


*/

type WorkflowJobTemplatesApiWorkflowJobTemplatesWorkflowJobTemplatesAccessListListOpts struct { 
	Page optional.Int32
	PageSize optional.Int32
	Search optional.String
}

func (a *WorkflowJobTemplatesApiService) WorkflowJobTemplatesWorkflowJobTemplatesAccessListList(ctx context.Context, id string, localVarOptionals *WorkflowJobTemplatesApiWorkflowJobTemplatesWorkflowJobTemplatesAccessListListOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v2/workflow_job_templates/{id}/access_list/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Page.IsSet() {
		localVarQueryParams.Add("page", parameterToString(localVarOptionals.Page.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PageSize.IsSet() {
		localVarQueryParams.Add("page_size", parameterToString(localVarOptionals.PageSize.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Search.IsSet() {
		localVarQueryParams.Add("search", parameterToString(localVarOptionals.Search.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
WorkflowJobTemplatesApiService  List Activity Streams for a Workflow Job Template
 Make a GET request to this resource to retrieve a list of activity streams associated with the selected workflow job template.  The resulting data structure contains:      {         \&quot;count\&quot;: 99,         \&quot;next\&quot;: null,         \&quot;previous\&quot;: null,         \&quot;results\&quot;: [             ...         ]     }  The &#x60;count&#x60; field indicates the total number of activity streams found for the given query.  The &#x60;next&#x60; and &#x60;previous&#x60; fields provides links to additional results if there are more than will fit on a single page.  The &#x60;results&#x60; list contains zero or more activity stream records.    ## Results  Each activity stream data structure includes the following fields:  * &#x60;id&#x60;: Database ID for this activity stream. (integer) * &#x60;type&#x60;: Data type for this activity stream. (choice) * &#x60;url&#x60;: URL for this activity stream. (string) * &#x60;related&#x60;: Data structure with URLs of related resources. (object) * &#x60;summary_fields&#x60;: Data structure with name/description for related resources.  The output for some objects may be limited for performance reasons. (object) * &#x60;timestamp&#x60;:  (datetime) * &#x60;operation&#x60;: The action taken with respect to the given object(s). (choice)     - &#x60;create&#x60;: Entity Created     - &#x60;update&#x60;: Entity Updated     - &#x60;delete&#x60;: Entity Deleted     - &#x60;associate&#x60;: Entity Associated with another Entity     - &#x60;disassociate&#x60;: Entity was Disassociated with another Entity * &#x60;changes&#x60;: A summary of the new and changed values when an object is created, updated, or deleted (json) * &#x60;object1&#x60;: For create, update, and delete events this is the object type that was affected. For associate and disassociate events this is the object type associated or disassociated with object2. (string) * &#x60;object2&#x60;: Unpopulated for create, update, and delete events. For associate and disassociate events this is the object type that object1 is being associated with. (string) * &#x60;object_association&#x60;: When present, shows the field name of the role or relationship that changed. (field) * &#x60;action_node&#x60;: The cluster node the activity took place on. (string) * &#x60;object_type&#x60;: When present, shows the model on which the role or relationship was defined. (field)    ## Sorting  To specify that activity streams are returned in a particular order, use the &#x60;order_by&#x60; query string parameter on the GET request.      ?order_by&#x3D;name  Prefix the field name with a dash &#x60;-&#x60; to sort in reverse:      ?order_by&#x3D;-name  Multiple sorting fields may be specified by separating the field names with a comma &#x60;,&#x60;:      ?order_by&#x3D;name,some_other_field  ## Pagination  Use the &#x60;page_size&#x60; query string parameter to change the number of results returned for each request.  Use the &#x60;page&#x60; query string parameter to retrieve a particular page of results.      ?page_size&#x3D;100&amp;page&#x3D;2  The &#x60;previous&#x60; and &#x60;next&#x60; links returned with the results will set these query string parameters automatically.  ## Searching  Use the &#x60;search&#x60; query string parameter to perform a case-insensitive search within all designated text fields of a model.      ?search&#x3D;findme  (_Added in Ansible Tower 3.1.0_) Search across related fields:      ?related__search&#x3D;findme
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id 
 * @param optional nil or *WorkflowJobTemplatesApiWorkflowJobTemplatesWorkflowJobTemplatesActivityStreamListOpts - Optional Parameters:
     * @param "Page" (optional.Int32) -  A page number within the paginated result set.
     * @param "PageSize" (optional.Int32) -  Number of results to return per page.
     * @param "Search" (optional.String) -  A search term.


*/

type WorkflowJobTemplatesApiWorkflowJobTemplatesWorkflowJobTemplatesActivityStreamListOpts struct { 
	Page optional.Int32
	PageSize optional.Int32
	Search optional.String
}

func (a *WorkflowJobTemplatesApiService) WorkflowJobTemplatesWorkflowJobTemplatesActivityStreamList(ctx context.Context, id string, localVarOptionals *WorkflowJobTemplatesApiWorkflowJobTemplatesWorkflowJobTemplatesActivityStreamListOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v2/workflow_job_templates/{id}/activity_stream/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Page.IsSet() {
		localVarQueryParams.Add("page", parameterToString(localVarOptionals.Page.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PageSize.IsSet() {
		localVarQueryParams.Add("page_size", parameterToString(localVarOptionals.PageSize.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Search.IsSet() {
		localVarQueryParams.Add("search", parameterToString(localVarOptionals.Search.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
WorkflowJobTemplatesApiService Copy a Workflow Job Template
 Make a GET request to this resource to determine if the current user has permission to copy the workflow job template and whether any linked templates or prompted fields will be ignored due to permissions problems. The response will include the following fields:  * &#x60;can_copy&#x60;: Flag indicating whether the active user has permission to make   a copy of this workflow job template, provides same content as the   workflow job template detail view summary_fields.user_capabilities.copy   (boolean, read-only) * &#x60;can_copy_without_user_input&#x60;: Flag indicating if the user should be   prompted for confirmation before the copy is executed (boolean, read-only) * &#x60;templates_unable_to_copy&#x60;: List of node ids of nodes that have a related   job template, project, or inventory that the current user lacks permission   to use and will be missing in workflow nodes of the copy (array, read-only) * &#x60;inventories_unable_to_copy&#x60;: List of node ids of nodes that have a related   prompted inventory that the current user lacks permission   to use and will be missing in workflow nodes of the copy (array, read-only) * &#x60;credentials_unable_to_copy&#x60;: List of node ids of nodes that have a related   prompted credential that the current user lacks permission   to use and will be missing in workflow nodes of the copy (array, read-only)  Make a POST request to this endpoint to save a copy of this workflow job template. No POST data is accepted for this action.  If successful, the response status code will be 201. The response body will contain serialized data about the new workflow job template, which will be similar to the original workflow job template, but with an additional &#x60;@&#x60; and a timestamp in the name.  All workflow nodes and connections in the original will also exist in the copy. The nodes will be missing related resources if the user did not have access to use them.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id 
 * @param optional nil or *WorkflowJobTemplatesApiWorkflowJobTemplatesWorkflowJobTemplatesCopyCreateOpts - Optional Parameters:
     * @param "Data" (optional.Interface of Data79) - 


*/

type WorkflowJobTemplatesApiWorkflowJobTemplatesWorkflowJobTemplatesCopyCreateOpts struct { 
	Data optional.Interface
}

func (a *WorkflowJobTemplatesApiService) WorkflowJobTemplatesWorkflowJobTemplatesCopyCreate(ctx context.Context, id string, localVarOptionals *WorkflowJobTemplatesApiWorkflowJobTemplatesWorkflowJobTemplatesCopyCreateOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v2/workflow_job_templates/{id}/copy/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Data.IsSet() {
		
		localVarOptionalData, localVarOptionalDataok := localVarOptionals.Data.Value().(Data79)
		if !localVarOptionalDataok {
				return nil, reportError("data should be Data79")
		}
		localVarPostBody = &localVarOptionalData
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
WorkflowJobTemplatesApiService Copy a Workflow Job Template
 Make a GET request to this resource to determine if the current user has permission to copy the workflow job template and whether any linked templates or prompted fields will be ignored due to permissions problems. The response will include the following fields:  * &#x60;can_copy&#x60;: Flag indicating whether the active user has permission to make   a copy of this workflow job template, provides same content as the   workflow job template detail view summary_fields.user_capabilities.copy   (boolean, read-only) * &#x60;can_copy_without_user_input&#x60;: Flag indicating if the user should be   prompted for confirmation before the copy is executed (boolean, read-only) * &#x60;templates_unable_to_copy&#x60;: List of node ids of nodes that have a related   job template, project, or inventory that the current user lacks permission   to use and will be missing in workflow nodes of the copy (array, read-only) * &#x60;inventories_unable_to_copy&#x60;: List of node ids of nodes that have a related   prompted inventory that the current user lacks permission   to use and will be missing in workflow nodes of the copy (array, read-only) * &#x60;credentials_unable_to_copy&#x60;: List of node ids of nodes that have a related   prompted credential that the current user lacks permission   to use and will be missing in workflow nodes of the copy (array, read-only)  Make a POST request to this endpoint to save a copy of this workflow job template. No POST data is accepted for this action.  If successful, the response status code will be 201. The response body will contain serialized data about the new workflow job template, which will be similar to the original workflow job template, but with an additional &#x60;@&#x60; and a timestamp in the name.  All workflow nodes and connections in the original will also exist in the copy. The nodes will be missing related resources if the user did not have access to use them.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id 
 * @param optional nil or *WorkflowJobTemplatesApiWorkflowJobTemplatesWorkflowJobTemplatesCopyListOpts - Optional Parameters:
     * @param "Page" (optional.Int32) -  A page number within the paginated result set.
     * @param "PageSize" (optional.Int32) -  Number of results to return per page.
     * @param "Search" (optional.String) -  A search term.


*/

type WorkflowJobTemplatesApiWorkflowJobTemplatesWorkflowJobTemplatesCopyListOpts struct { 
	Page optional.Int32
	PageSize optional.Int32
	Search optional.String
}

func (a *WorkflowJobTemplatesApiService) WorkflowJobTemplatesWorkflowJobTemplatesCopyList(ctx context.Context, id string, localVarOptionals *WorkflowJobTemplatesApiWorkflowJobTemplatesWorkflowJobTemplatesCopyListOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v2/workflow_job_templates/{id}/copy/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Page.IsSet() {
		localVarQueryParams.Add("page", parameterToString(localVarOptionals.Page.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PageSize.IsSet() {
		localVarQueryParams.Add("page_size", parameterToString(localVarOptionals.PageSize.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Search.IsSet() {
		localVarQueryParams.Add("search", parameterToString(localVarOptionals.Search.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
WorkflowJobTemplatesApiService  Create a Workflow Job Template
 Make a POST request to this resource with the following workflow job template fields to create a new workflow job template:          * &#x60;name&#x60;: Name of this workflow job template. (string, required) * &#x60;description&#x60;: Optional description of this workflow job template. (string, default&#x3D;&#x60;\&quot;\&quot;&#x60;)     * &#x60;extra_vars&#x60;:  (json, default&#x3D;&#x60;&#x60;) * &#x60;organization&#x60;: The organization used to determine access to this template. (id, default&#x3D;&#x60;&#x60;) * &#x60;survey_enabled&#x60;:  (boolean, default&#x3D;&#x60;False&#x60;) * &#x60;allow_simultaneous&#x60;:  (boolean, default&#x3D;&#x60;False&#x60;) * &#x60;ask_variables_on_launch&#x60;:  (boolean, default&#x3D;&#x60;False&#x60;) * &#x60;inventory&#x60;: Inventory applied as a prompt, assuming job template prompts for inventory (id, default&#x3D;&#x60;&#x60;) * &#x60;limit&#x60;:  (string, default&#x3D;&#x60;\&quot;\&quot;&#x60;) * &#x60;scm_branch&#x60;:  (string, default&#x3D;&#x60;\&quot;\&quot;&#x60;) * &#x60;ask_inventory_on_launch&#x60;:  (boolean, default&#x3D;&#x60;False&#x60;) * &#x60;ask_scm_branch_on_launch&#x60;:  (boolean, default&#x3D;&#x60;False&#x60;) * &#x60;ask_limit_on_launch&#x60;:  (boolean, default&#x3D;&#x60;False&#x60;) * &#x60;webhook_service&#x60;: Service that webhook requests will be accepted from (choice)     - &#x60;\&quot;\&quot;&#x60;: ---------     - &#x60;github&#x60;: GitHub     - &#x60;gitlab&#x60;: GitLab * &#x60;webhook_credential&#x60;: Personal Access Token for posting back the status to the service API (id, default&#x3D;&#x60;&#x60;)
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *WorkflowJobTemplatesApiWorkflowJobTemplatesWorkflowJobTemplatesCreateOpts - Optional Parameters:
     * @param "Data" (optional.Interface of Data77) - 


*/

type WorkflowJobTemplatesApiWorkflowJobTemplatesWorkflowJobTemplatesCreateOpts struct { 
	Data optional.Interface
}

func (a *WorkflowJobTemplatesApiService) WorkflowJobTemplatesWorkflowJobTemplatesCreate(ctx context.Context, localVarOptionals *WorkflowJobTemplatesApiWorkflowJobTemplatesWorkflowJobTemplatesCreateOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v2/workflow_job_templates/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Data.IsSet() {
		
		localVarOptionalData, localVarOptionalDataok := localVarOptionals.Data.Value().(Data77)
		if !localVarOptionalDataok {
				return nil, reportError("data should be Data77")
		}
		localVarPostBody = &localVarOptionalData
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
WorkflowJobTemplatesApiService  Delete a Workflow Job Template
 Make a DELETE request to this resource to delete this workflow job template.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id 
 * @param optional nil or *WorkflowJobTemplatesApiWorkflowJobTemplatesWorkflowJobTemplatesDeleteOpts - Optional Parameters:
     * @param "Search" (optional.String) -  A search term.


*/

type WorkflowJobTemplatesApiWorkflowJobTemplatesWorkflowJobTemplatesDeleteOpts struct { 
	Search optional.String
}

func (a *WorkflowJobTemplatesApiService) WorkflowJobTemplatesWorkflowJobTemplatesDelete(ctx context.Context, id string, localVarOptionals *WorkflowJobTemplatesApiWorkflowJobTemplatesWorkflowJobTemplatesDeleteOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v2/workflow_job_templates/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Search.IsSet() {
		localVarQueryParams.Add("search", parameterToString(localVarOptionals.Search.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
WorkflowJobTemplatesApiService
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id 


*/
func (a *WorkflowJobTemplatesApiService) WorkflowJobTemplatesWorkflowJobTemplatesGithubCreate(ctx context.Context, id string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v2/workflow_job_templates/{id}/github/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
WorkflowJobTemplatesApiService
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id 


*/
func (a *WorkflowJobTemplatesApiService) WorkflowJobTemplatesWorkflowJobTemplatesGitlabCreate(ctx context.Context, id string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v2/workflow_job_templates/{id}/gitlab/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
WorkflowJobTemplatesApiService  Create a Label for a Workflow Job Template
 Make a POST request to this resource with the following label fields to create a new label associated with this workflow job template.          * &#x60;name&#x60;: Name of this label. (string, required) * &#x60;organization&#x60;: Organization this label belongs to. (id, required)         # Add Labels for a Workflow Job Template:  Make a POST request to this resource with only an &#x60;id&#x60; field to associate an existing label with this workflow job template.  # Remove Labels from this Workflow Job Template:  Make a POST request to this resource with &#x60;id&#x60; and &#x60;disassociate&#x60; fields to remove the label from this workflow job template .     Labels not associated with any other resources are deleted. A label can become disassociated with a resource as a result of 3 events.  1. A label is explicitly disassociated with a related job template 2. A job is deleted with labels 3. A cleanup job deletes a job with labels
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id 
 * @param optional nil or *WorkflowJobTemplatesApiWorkflowJobTemplatesWorkflowJobTemplatesLabelsCreateOpts - Optional Parameters:
     * @param "Data" (optional.Interface of Data80) - 


*/

type WorkflowJobTemplatesApiWorkflowJobTemplatesWorkflowJobTemplatesLabelsCreateOpts struct { 
	Data optional.Interface
}

func (a *WorkflowJobTemplatesApiService) WorkflowJobTemplatesWorkflowJobTemplatesLabelsCreate(ctx context.Context, id string, localVarOptionals *WorkflowJobTemplatesApiWorkflowJobTemplatesWorkflowJobTemplatesLabelsCreateOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v2/workflow_job_templates/{id}/labels/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Data.IsSet() {
		
		localVarOptionalData, localVarOptionalDataok := localVarOptionals.Data.Value().(Data80)
		if !localVarOptionalDataok {
				return nil, reportError("data should be Data80")
		}
		localVarPostBody = &localVarOptionalData
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
WorkflowJobTemplatesApiService  List Labels for a Workflow Job Template
 Make a GET request to this resource to retrieve a list of labels associated with the selected workflow job template.  The resulting data structure contains:      {         \&quot;count\&quot;: 99,         \&quot;next\&quot;: null,         \&quot;previous\&quot;: null,         \&quot;results\&quot;: [             ...         ]     }  The &#x60;count&#x60; field indicates the total number of labels found for the given query.  The &#x60;next&#x60; and &#x60;previous&#x60; fields provides links to additional results if there are more than will fit on a single page.  The &#x60;results&#x60; list contains zero or more label records.    ## Results  Each label data structure includes the following fields:  * &#x60;id&#x60;: Database ID for this label. (integer) * &#x60;type&#x60;: Data type for this label. (choice) * &#x60;url&#x60;: URL for this label. (string) * &#x60;related&#x60;: Data structure with URLs of related resources. (object) * &#x60;summary_fields&#x60;: Data structure with name/description for related resources.  The output for some objects may be limited for performance reasons. (object) * &#x60;created&#x60;: Timestamp when this label was created. (datetime) * &#x60;modified&#x60;: Timestamp when this label was last modified. (datetime) * &#x60;name&#x60;: Name of this label. (string) * &#x60;organization&#x60;: Organization this label belongs to. (id)    ## Sorting  To specify that labels are returned in a particular order, use the &#x60;order_by&#x60; query string parameter on the GET request.      ?order_by&#x3D;name  Prefix the field name with a dash &#x60;-&#x60; to sort in reverse:      ?order_by&#x3D;-name  Multiple sorting fields may be specified by separating the field names with a comma &#x60;,&#x60;:      ?order_by&#x3D;name,some_other_field  ## Pagination  Use the &#x60;page_size&#x60; query string parameter to change the number of results returned for each request.  Use the &#x60;page&#x60; query string parameter to retrieve a particular page of results.      ?page_size&#x3D;100&amp;page&#x3D;2  The &#x60;previous&#x60; and &#x60;next&#x60; links returned with the results will set these query string parameters automatically.  ## Searching  Use the &#x60;search&#x60; query string parameter to perform a case-insensitive search within all designated text fields of a model.      ?search&#x3D;findme  (_Added in Ansible Tower 3.1.0_) Search across related fields:      ?related__search&#x3D;findme
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id 
 * @param optional nil or *WorkflowJobTemplatesApiWorkflowJobTemplatesWorkflowJobTemplatesLabelsListOpts - Optional Parameters:
     * @param "Page" (optional.Int32) -  A page number within the paginated result set.
     * @param "PageSize" (optional.Int32) -  Number of results to return per page.
     * @param "Search" (optional.String) -  A search term.


*/

type WorkflowJobTemplatesApiWorkflowJobTemplatesWorkflowJobTemplatesLabelsListOpts struct { 
	Page optional.Int32
	PageSize optional.Int32
	Search optional.String
}

func (a *WorkflowJobTemplatesApiService) WorkflowJobTemplatesWorkflowJobTemplatesLabelsList(ctx context.Context, id string, localVarOptionals *WorkflowJobTemplatesApiWorkflowJobTemplatesWorkflowJobTemplatesLabelsListOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v2/workflow_job_templates/{id}/labels/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Page.IsSet() {
		localVarQueryParams.Add("page", parameterToString(localVarOptionals.Page.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PageSize.IsSet() {
		localVarQueryParams.Add("page_size", parameterToString(localVarOptionals.PageSize.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Search.IsSet() {
		localVarQueryParams.Add("search", parameterToString(localVarOptionals.Search.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
WorkflowJobTemplatesApiService Launch a Workflow Job Template
 Make a GET request to this resource to determine if the workflow_job_template can be launched and whether any passwords are required to launch the workflow_job_template. The response will include the following fields:  * &#x60;can_start_without_user_input&#x60;: Flag indicating if the workflow_job_template   can be launched without user-input (boolean, read-only) * &#x60;variables_needed_to_start&#x60;: Required variable names required to launch the   workflow_job_template (array, read-only) * &#x60;survey_enabled&#x60;: Flag indicating whether the workflow_job_template has an   enabled survey (boolean, read-only) * &#x60;extra_vars&#x60;: Text which is the &#x60;extra_vars&#x60; field of this workflow_job_template   (text, read-only) * &#x60;node_templates_missing&#x60;: List of node ids of all nodes that have a   null &#x60;unified_job_template&#x60;, which will cause their branches to stop   execution (list, read-only) * &#x60;node_prompts_rejected&#x60;: List of node ids of all nodes that have   specified a field that will be rejected because its  &#x60;unified_job_template&#x60;   does not allow prompting for this field, this will not halt execution of   the branch but the field will be ignored (list, read-only) * &#x60;workflow_job_template_data&#x60;: JSON object listing general information of   this workflow_job_template (JSON object, read-only)  Make a POST request to this resource to launch the workflow_job_template. If any credential, inventory, project or extra variables (extra_vars) are required, they must be passed via POST data, with extra_vars given as a YAML or JSON string and escaped parentheses.  If successful, the response status code will be 201.  If any required passwords are not provided, a 400 status code will be returned.  If the workflow job cannot be launched, a 405 status code will be returned. If the provided credential or inventory are not allowed to be used by the user, then a 403 status code will be returned.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id 
 * @param optional nil or *WorkflowJobTemplatesApiWorkflowJobTemplatesWorkflowJobTemplatesLaunchCreateOpts - Optional Parameters:
     * @param "Data" (optional.Interface of Data81) - 


*/

type WorkflowJobTemplatesApiWorkflowJobTemplatesWorkflowJobTemplatesLaunchCreateOpts struct { 
	Data optional.Interface
}

func (a *WorkflowJobTemplatesApiService) WorkflowJobTemplatesWorkflowJobTemplatesLaunchCreate(ctx context.Context, id string, localVarOptionals *WorkflowJobTemplatesApiWorkflowJobTemplatesWorkflowJobTemplatesLaunchCreateOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v2/workflow_job_templates/{id}/launch/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Data.IsSet() {
		
		localVarOptionalData, localVarOptionalDataok := localVarOptionals.Data.Value().(Data81)
		if !localVarOptionalDataok {
				return nil, reportError("data should be Data81")
		}
		localVarPostBody = &localVarOptionalData
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
WorkflowJobTemplatesApiService Launch a Workflow Job Template
 Make a GET request to this resource to determine if the workflow_job_template can be launched and whether any passwords are required to launch the workflow_job_template. The response will include the following fields:  * &#x60;can_start_without_user_input&#x60;: Flag indicating if the workflow_job_template   can be launched without user-input (boolean, read-only) * &#x60;variables_needed_to_start&#x60;: Required variable names required to launch the   workflow_job_template (array, read-only) * &#x60;survey_enabled&#x60;: Flag indicating whether the workflow_job_template has an   enabled survey (boolean, read-only) * &#x60;extra_vars&#x60;: Text which is the &#x60;extra_vars&#x60; field of this workflow_job_template   (text, read-only) * &#x60;node_templates_missing&#x60;: List of node ids of all nodes that have a   null &#x60;unified_job_template&#x60;, which will cause their branches to stop   execution (list, read-only) * &#x60;node_prompts_rejected&#x60;: List of node ids of all nodes that have   specified a field that will be rejected because its  &#x60;unified_job_template&#x60;   does not allow prompting for this field, this will not halt execution of   the branch but the field will be ignored (list, read-only) * &#x60;workflow_job_template_data&#x60;: JSON object listing general information of   this workflow_job_template (JSON object, read-only)  Make a POST request to this resource to launch the workflow_job_template. If any credential, inventory, project or extra variables (extra_vars) are required, they must be passed via POST data, with extra_vars given as a YAML or JSON string and escaped parentheses.  If successful, the response status code will be 201.  If any required passwords are not provided, a 400 status code will be returned.  If the workflow job cannot be launched, a 405 status code will be returned. If the provided credential or inventory are not allowed to be used by the user, then a 403 status code will be returned.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id 
 * @param optional nil or *WorkflowJobTemplatesApiWorkflowJobTemplatesWorkflowJobTemplatesLaunchReadOpts - Optional Parameters:
     * @param "Search" (optional.String) -  A search term.


*/

type WorkflowJobTemplatesApiWorkflowJobTemplatesWorkflowJobTemplatesLaunchReadOpts struct { 
	Search optional.String
}

func (a *WorkflowJobTemplatesApiService) WorkflowJobTemplatesWorkflowJobTemplatesLaunchRead(ctx context.Context, id string, localVarOptionals *WorkflowJobTemplatesApiWorkflowJobTemplatesWorkflowJobTemplatesLaunchReadOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v2/workflow_job_templates/{id}/launch/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Search.IsSet() {
		localVarQueryParams.Add("search", parameterToString(localVarOptionals.Search.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
WorkflowJobTemplatesApiService  List Workflow Job Templates
 Make a GET request to this resource to retrieve the list of workflow job templates.  The resulting data structure contains:      {         \&quot;count\&quot;: 99,         \&quot;next\&quot;: null,         \&quot;previous\&quot;: null,         \&quot;results\&quot;: [             ...         ]     }  The &#x60;count&#x60; field indicates the total number of workflow job templates found for the given query.  The &#x60;next&#x60; and &#x60;previous&#x60; fields provides links to additional results if there are more than will fit on a single page.  The &#x60;results&#x60; list contains zero or more workflow job template records.    ## Results  Each workflow job template data structure includes the following fields:  * &#x60;id&#x60;: Database ID for this workflow job template. (integer) * &#x60;type&#x60;: Data type for this workflow job template. (choice) * &#x60;url&#x60;: URL for this workflow job template. (string) * &#x60;related&#x60;: Data structure with URLs of related resources. (object) * &#x60;summary_fields&#x60;: Data structure with name/description for related resources.  The output for some objects may be limited for performance reasons. (object) * &#x60;created&#x60;: Timestamp when this workflow job template was created. (datetime) * &#x60;modified&#x60;: Timestamp when this workflow job template was last modified. (datetime) * &#x60;name&#x60;: Name of this workflow job template. (string) * &#x60;description&#x60;: Optional description of this workflow job template. (string) * &#x60;last_job_run&#x60;:  (datetime) * &#x60;last_job_failed&#x60;:  (boolean) * &#x60;next_job_run&#x60;:  (datetime) * &#x60;status&#x60;:  (choice)     - &#x60;new&#x60;: New     - &#x60;pending&#x60;: Pending     - &#x60;waiting&#x60;: Waiting     - &#x60;running&#x60;: Running     - &#x60;successful&#x60;: Successful     - &#x60;failed&#x60;: Failed     - &#x60;error&#x60;: Error     - &#x60;canceled&#x60;: Canceled     - &#x60;never updated&#x60;: Never Updated     - &#x60;ok&#x60;: OK     - &#x60;missing&#x60;: Missing     - &#x60;none&#x60;: No External Source     - &#x60;updating&#x60;: Updating * &#x60;extra_vars&#x60;:  (json) * &#x60;organization&#x60;: The organization used to determine access to this template. (id) * &#x60;survey_enabled&#x60;:  (boolean) * &#x60;allow_simultaneous&#x60;:  (boolean) * &#x60;ask_variables_on_launch&#x60;:  (boolean) * &#x60;inventory&#x60;: Inventory applied as a prompt, assuming job template prompts for inventory (id) * &#x60;limit&#x60;:  (string) * &#x60;scm_branch&#x60;:  (string) * &#x60;ask_inventory_on_launch&#x60;:  (boolean) * &#x60;ask_scm_branch_on_launch&#x60;:  (boolean) * &#x60;ask_limit_on_launch&#x60;:  (boolean) * &#x60;webhook_service&#x60;: Service that webhook requests will be accepted from (choice)     - &#x60;\&quot;\&quot;&#x60;: ---------     - &#x60;github&#x60;: GitHub     - &#x60;gitlab&#x60;: GitLab * &#x60;webhook_credential&#x60;: Personal Access Token for posting back the status to the service API (id)    ## Sorting  To specify that workflow job templates are returned in a particular order, use the &#x60;order_by&#x60; query string parameter on the GET request.      ?order_by&#x3D;name  Prefix the field name with a dash &#x60;-&#x60; to sort in reverse:      ?order_by&#x3D;-name  Multiple sorting fields may be specified by separating the field names with a comma &#x60;,&#x60;:      ?order_by&#x3D;name,some_other_field  ## Pagination  Use the &#x60;page_size&#x60; query string parameter to change the number of results returned for each request.  Use the &#x60;page&#x60; query string parameter to retrieve a particular page of results.      ?page_size&#x3D;100&amp;page&#x3D;2  The &#x60;previous&#x60; and &#x60;next&#x60; links returned with the results will set these query string parameters automatically.  ## Searching  Use the &#x60;search&#x60; query string parameter to perform a case-insensitive search within all designated text fields of a model.      ?search&#x3D;findme  (_Added in Ansible Tower 3.1.0_) Search across related fields:      ?related__search&#x3D;findme
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *WorkflowJobTemplatesApiWorkflowJobTemplatesWorkflowJobTemplatesListOpts - Optional Parameters:
     * @param "Page" (optional.Int32) -  A page number within the paginated result set.
     * @param "PageSize" (optional.Int32) -  Number of results to return per page.
     * @param "Search" (optional.String) -  A search term.


*/

type WorkflowJobTemplatesApiWorkflowJobTemplatesWorkflowJobTemplatesListOpts struct { 
	Page optional.Int32
	PageSize optional.Int32
	Search optional.String
}

func (a *WorkflowJobTemplatesApiService) WorkflowJobTemplatesWorkflowJobTemplatesList(ctx context.Context, localVarOptionals *WorkflowJobTemplatesApiWorkflowJobTemplatesWorkflowJobTemplatesListOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v2/workflow_job_templates/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Page.IsSet() {
		localVarQueryParams.Add("page", parameterToString(localVarOptionals.Page.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PageSize.IsSet() {
		localVarQueryParams.Add("page_size", parameterToString(localVarOptionals.PageSize.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Search.IsSet() {
		localVarQueryParams.Add("search", parameterToString(localVarOptionals.Search.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
WorkflowJobTemplatesApiService  Create a Notification Template for a Workflow Job Template
 Make a POST request to this resource with the following notification template fields to create a new notification template associated with this workflow job template.          * &#x60;name&#x60;: Name of this notification template. (string, required) * &#x60;description&#x60;: Optional description of this notification template. (string, default&#x3D;&#x60;\&quot;\&quot;&#x60;) * &#x60;organization&#x60;:  (id, required) * &#x60;notification_type&#x60;:  (choice, required)     - &#x60;email&#x60;: Email     - &#x60;grafana&#x60;: Grafana     - &#x60;irc&#x60;: IRC     - &#x60;mattermost&#x60;: Mattermost     - &#x60;pagerduty&#x60;: Pagerduty     - &#x60;rocketchat&#x60;: Rocket.Chat     - &#x60;slack&#x60;: Slack     - &#x60;twilio&#x60;: Twilio     - &#x60;webhook&#x60;: Webhook * &#x60;notification_configuration&#x60;:  (json, default&#x3D;&#x60;{}&#x60;) * &#x60;messages&#x60;: Optional custom messages for notification template. (json, default&#x3D;&#x60;{&amp;#39;started&amp;#39;: None, &amp;#39;success&amp;#39;: None, &amp;#39;error&amp;#39;: None, &amp;#39;workflow_approval&amp;#39;: None}&#x60;)         # Add Notification Templates for a Workflow Job Template:  Make a POST request to this resource with only an &#x60;id&#x60; field to associate an existing notification template with this workflow job template.  # Remove Notification Templates from this Workflow Job Template:  Make a POST request to this resource with &#x60;id&#x60; and &#x60;disassociate&#x60; fields to remove the notification template from this workflow job template  without deleting the notification template.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id 
 * @param optional nil or *WorkflowJobTemplatesApiWorkflowJobTemplatesWorkflowJobTemplatesNotificationTemplatesApprovalsCreateOpts - Optional Parameters:
     * @param "Data" (optional.Interface{}) - 


*/

type WorkflowJobTemplatesApiWorkflowJobTemplatesWorkflowJobTemplatesNotificationTemplatesApprovalsCreateOpts struct { 
	Data optional.Interface{}
}

func (a *WorkflowJobTemplatesApiService) WorkflowJobTemplatesWorkflowJobTemplatesNotificationTemplatesApprovalsCreate(ctx context.Context, id string, localVarOptionals *WorkflowJobTemplatesApiWorkflowJobTemplatesWorkflowJobTemplatesNotificationTemplatesApprovalsCreateOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v2/workflow_job_templates/{id}/notification_templates_approvals/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Data.IsSet() {
		localVarPostBody = &localVarOptionals.Data.Value()
		
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
WorkflowJobTemplatesApiService  List Notification Templates for a Workflow Job Template
 Make a GET request to this resource to retrieve a list of notification templates associated with the selected workflow job template.  The resulting data structure contains:      {         \&quot;count\&quot;: 99,         \&quot;next\&quot;: null,         \&quot;previous\&quot;: null,         \&quot;results\&quot;: [             ...         ]     }  The &#x60;count&#x60; field indicates the total number of notification templates found for the given query.  The &#x60;next&#x60; and &#x60;previous&#x60; fields provides links to additional results if there are more than will fit on a single page.  The &#x60;results&#x60; list contains zero or more notification template records.    ## Results  Each notification template data structure includes the following fields:  * &#x60;id&#x60;: Database ID for this notification template. (integer) * &#x60;type&#x60;: Data type for this notification template. (choice) * &#x60;url&#x60;: URL for this notification template. (string) * &#x60;related&#x60;: Data structure with URLs of related resources. (object) * &#x60;summary_fields&#x60;: Data structure with name/description for related resources.  The output for some objects may be limited for performance reasons. (object) * &#x60;created&#x60;: Timestamp when this notification template was created. (datetime) * &#x60;modified&#x60;: Timestamp when this notification template was last modified. (datetime) * &#x60;name&#x60;: Name of this notification template. (string) * &#x60;description&#x60;: Optional description of this notification template. (string) * &#x60;organization&#x60;:  (id) * &#x60;notification_type&#x60;:  (choice)     - &#x60;email&#x60;: Email     - &#x60;grafana&#x60;: Grafana     - &#x60;irc&#x60;: IRC     - &#x60;mattermost&#x60;: Mattermost     - &#x60;pagerduty&#x60;: Pagerduty     - &#x60;rocketchat&#x60;: Rocket.Chat     - &#x60;slack&#x60;: Slack     - &#x60;twilio&#x60;: Twilio     - &#x60;webhook&#x60;: Webhook * &#x60;notification_configuration&#x60;:  (json) * &#x60;messages&#x60;: Optional custom messages for notification template. (json)    ## Sorting  To specify that notification templates are returned in a particular order, use the &#x60;order_by&#x60; query string parameter on the GET request.      ?order_by&#x3D;name  Prefix the field name with a dash &#x60;-&#x60; to sort in reverse:      ?order_by&#x3D;-name  Multiple sorting fields may be specified by separating the field names with a comma &#x60;,&#x60;:      ?order_by&#x3D;name,some_other_field  ## Pagination  Use the &#x60;page_size&#x60; query string parameter to change the number of results returned for each request.  Use the &#x60;page&#x60; query string parameter to retrieve a particular page of results.      ?page_size&#x3D;100&amp;page&#x3D;2  The &#x60;previous&#x60; and &#x60;next&#x60; links returned with the results will set these query string parameters automatically.  ## Searching  Use the &#x60;search&#x60; query string parameter to perform a case-insensitive search within all designated text fields of a model.      ?search&#x3D;findme  (_Added in Ansible Tower 3.1.0_) Search across related fields:      ?related__search&#x3D;findme
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id 
 * @param optional nil or *WorkflowJobTemplatesApiWorkflowJobTemplatesWorkflowJobTemplatesNotificationTemplatesApprovalsListOpts - Optional Parameters:
     * @param "Page" (optional.Int32) -  A page number within the paginated result set.
     * @param "PageSize" (optional.Int32) -  Number of results to return per page.
     * @param "Search" (optional.String) -  A search term.


*/

type WorkflowJobTemplatesApiWorkflowJobTemplatesWorkflowJobTemplatesNotificationTemplatesApprovalsListOpts struct { 
	Page optional.Int32
	PageSize optional.Int32
	Search optional.String
}

func (a *WorkflowJobTemplatesApiService) WorkflowJobTemplatesWorkflowJobTemplatesNotificationTemplatesApprovalsList(ctx context.Context, id string, localVarOptionals *WorkflowJobTemplatesApiWorkflowJobTemplatesWorkflowJobTemplatesNotificationTemplatesApprovalsListOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v2/workflow_job_templates/{id}/notification_templates_approvals/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Page.IsSet() {
		localVarQueryParams.Add("page", parameterToString(localVarOptionals.Page.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PageSize.IsSet() {
		localVarQueryParams.Add("page_size", parameterToString(localVarOptionals.PageSize.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Search.IsSet() {
		localVarQueryParams.Add("search", parameterToString(localVarOptionals.Search.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
WorkflowJobTemplatesApiService  Create a Notification Template for a Workflow Job Template
 Make a POST request to this resource with the following notification template fields to create a new notification template associated with this workflow job template.          * &#x60;name&#x60;: Name of this notification template. (string, required) * &#x60;description&#x60;: Optional description of this notification template. (string, default&#x3D;&#x60;\&quot;\&quot;&#x60;) * &#x60;organization&#x60;:  (id, required) * &#x60;notification_type&#x60;:  (choice, required)     - &#x60;email&#x60;: Email     - &#x60;grafana&#x60;: Grafana     - &#x60;irc&#x60;: IRC     - &#x60;mattermost&#x60;: Mattermost     - &#x60;pagerduty&#x60;: Pagerduty     - &#x60;rocketchat&#x60;: Rocket.Chat     - &#x60;slack&#x60;: Slack     - &#x60;twilio&#x60;: Twilio     - &#x60;webhook&#x60;: Webhook * &#x60;notification_configuration&#x60;:  (json, default&#x3D;&#x60;{}&#x60;) * &#x60;messages&#x60;: Optional custom messages for notification template. (json, default&#x3D;&#x60;{&amp;#39;started&amp;#39;: None, &amp;#39;success&amp;#39;: None, &amp;#39;error&amp;#39;: None, &amp;#39;workflow_approval&amp;#39;: None}&#x60;)         # Add Notification Templates for a Workflow Job Template:  Make a POST request to this resource with only an &#x60;id&#x60; field to associate an existing notification template with this workflow job template.  # Remove Notification Templates from this Workflow Job Template:  Make a POST request to this resource with &#x60;id&#x60; and &#x60;disassociate&#x60; fields to remove the notification template from this workflow job template  without deleting the notification template.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id 
 * @param optional nil or *WorkflowJobTemplatesApiWorkflowJobTemplatesWorkflowJobTemplatesNotificationTemplatesErrorCreateOpts - Optional Parameters:
     * @param "Data" (optional.Interface of Data82) - 


*/

type WorkflowJobTemplatesApiWorkflowJobTemplatesWorkflowJobTemplatesNotificationTemplatesErrorCreateOpts struct { 
	Data optional.Interface
}

func (a *WorkflowJobTemplatesApiService) WorkflowJobTemplatesWorkflowJobTemplatesNotificationTemplatesErrorCreate(ctx context.Context, id string, localVarOptionals *WorkflowJobTemplatesApiWorkflowJobTemplatesWorkflowJobTemplatesNotificationTemplatesErrorCreateOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v2/workflow_job_templates/{id}/notification_templates_error/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Data.IsSet() {
		
		localVarOptionalData, localVarOptionalDataok := localVarOptionals.Data.Value().(Data82)
		if !localVarOptionalDataok {
				return nil, reportError("data should be Data82")
		}
		localVarPostBody = &localVarOptionalData
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
WorkflowJobTemplatesApiService  List Notification Templates for a Workflow Job Template
 Make a GET request to this resource to retrieve a list of notification templates associated with the selected workflow job template.  The resulting data structure contains:      {         \&quot;count\&quot;: 99,         \&quot;next\&quot;: null,         \&quot;previous\&quot;: null,         \&quot;results\&quot;: [             ...         ]     }  The &#x60;count&#x60; field indicates the total number of notification templates found for the given query.  The &#x60;next&#x60; and &#x60;previous&#x60; fields provides links to additional results if there are more than will fit on a single page.  The &#x60;results&#x60; list contains zero or more notification template records.    ## Results  Each notification template data structure includes the following fields:  * &#x60;id&#x60;: Database ID for this notification template. (integer) * &#x60;type&#x60;: Data type for this notification template. (choice) * &#x60;url&#x60;: URL for this notification template. (string) * &#x60;related&#x60;: Data structure with URLs of related resources. (object) * &#x60;summary_fields&#x60;: Data structure with name/description for related resources.  The output for some objects may be limited for performance reasons. (object) * &#x60;created&#x60;: Timestamp when this notification template was created. (datetime) * &#x60;modified&#x60;: Timestamp when this notification template was last modified. (datetime) * &#x60;name&#x60;: Name of this notification template. (string) * &#x60;description&#x60;: Optional description of this notification template. (string) * &#x60;organization&#x60;:  (id) * &#x60;notification_type&#x60;:  (choice)     - &#x60;email&#x60;: Email     - &#x60;grafana&#x60;: Grafana     - &#x60;irc&#x60;: IRC     - &#x60;mattermost&#x60;: Mattermost     - &#x60;pagerduty&#x60;: Pagerduty     - &#x60;rocketchat&#x60;: Rocket.Chat     - &#x60;slack&#x60;: Slack     - &#x60;twilio&#x60;: Twilio     - &#x60;webhook&#x60;: Webhook * &#x60;notification_configuration&#x60;:  (json) * &#x60;messages&#x60;: Optional custom messages for notification template. (json)    ## Sorting  To specify that notification templates are returned in a particular order, use the &#x60;order_by&#x60; query string parameter on the GET request.      ?order_by&#x3D;name  Prefix the field name with a dash &#x60;-&#x60; to sort in reverse:      ?order_by&#x3D;-name  Multiple sorting fields may be specified by separating the field names with a comma &#x60;,&#x60;:      ?order_by&#x3D;name,some_other_field  ## Pagination  Use the &#x60;page_size&#x60; query string parameter to change the number of results returned for each request.  Use the &#x60;page&#x60; query string parameter to retrieve a particular page of results.      ?page_size&#x3D;100&amp;page&#x3D;2  The &#x60;previous&#x60; and &#x60;next&#x60; links returned with the results will set these query string parameters automatically.  ## Searching  Use the &#x60;search&#x60; query string parameter to perform a case-insensitive search within all designated text fields of a model.      ?search&#x3D;findme  (_Added in Ansible Tower 3.1.0_) Search across related fields:      ?related__search&#x3D;findme
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id 
 * @param optional nil or *WorkflowJobTemplatesApiWorkflowJobTemplatesWorkflowJobTemplatesNotificationTemplatesErrorListOpts - Optional Parameters:
     * @param "Page" (optional.Int32) -  A page number within the paginated result set.
     * @param "PageSize" (optional.Int32) -  Number of results to return per page.
     * @param "Search" (optional.String) -  A search term.


*/

type WorkflowJobTemplatesApiWorkflowJobTemplatesWorkflowJobTemplatesNotificationTemplatesErrorListOpts struct { 
	Page optional.Int32
	PageSize optional.Int32
	Search optional.String
}

func (a *WorkflowJobTemplatesApiService) WorkflowJobTemplatesWorkflowJobTemplatesNotificationTemplatesErrorList(ctx context.Context, id string, localVarOptionals *WorkflowJobTemplatesApiWorkflowJobTemplatesWorkflowJobTemplatesNotificationTemplatesErrorListOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v2/workflow_job_templates/{id}/notification_templates_error/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Page.IsSet() {
		localVarQueryParams.Add("page", parameterToString(localVarOptionals.Page.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PageSize.IsSet() {
		localVarQueryParams.Add("page_size", parameterToString(localVarOptionals.PageSize.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Search.IsSet() {
		localVarQueryParams.Add("search", parameterToString(localVarOptionals.Search.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
WorkflowJobTemplatesApiService  Create a Notification Template for a Workflow Job Template
 Make a POST request to this resource with the following notification template fields to create a new notification template associated with this workflow job template.          * &#x60;name&#x60;: Name of this notification template. (string, required) * &#x60;description&#x60;: Optional description of this notification template. (string, default&#x3D;&#x60;\&quot;\&quot;&#x60;) * &#x60;organization&#x60;:  (id, required) * &#x60;notification_type&#x60;:  (choice, required)     - &#x60;email&#x60;: Email     - &#x60;grafana&#x60;: Grafana     - &#x60;irc&#x60;: IRC     - &#x60;mattermost&#x60;: Mattermost     - &#x60;pagerduty&#x60;: Pagerduty     - &#x60;rocketchat&#x60;: Rocket.Chat     - &#x60;slack&#x60;: Slack     - &#x60;twilio&#x60;: Twilio     - &#x60;webhook&#x60;: Webhook * &#x60;notification_configuration&#x60;:  (json, default&#x3D;&#x60;{}&#x60;) * &#x60;messages&#x60;: Optional custom messages for notification template. (json, default&#x3D;&#x60;{&amp;#39;started&amp;#39;: None, &amp;#39;success&amp;#39;: None, &amp;#39;error&amp;#39;: None, &amp;#39;workflow_approval&amp;#39;: None}&#x60;)         # Add Notification Templates for a Workflow Job Template:  Make a POST request to this resource with only an &#x60;id&#x60; field to associate an existing notification template with this workflow job template.  # Remove Notification Templates from this Workflow Job Template:  Make a POST request to this resource with &#x60;id&#x60; and &#x60;disassociate&#x60; fields to remove the notification template from this workflow job template  without deleting the notification template.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id 
 * @param optional nil or *WorkflowJobTemplatesApiWorkflowJobTemplatesWorkflowJobTemplatesNotificationTemplatesStartedCreateOpts - Optional Parameters:
     * @param "Data" (optional.Interface{}) - 


*/

type WorkflowJobTemplatesApiWorkflowJobTemplatesWorkflowJobTemplatesNotificationTemplatesStartedCreateOpts struct { 
	Data optional.Interface{}
}

func (a *WorkflowJobTemplatesApiService) WorkflowJobTemplatesWorkflowJobTemplatesNotificationTemplatesStartedCreate(ctx context.Context, id string, localVarOptionals *WorkflowJobTemplatesApiWorkflowJobTemplatesWorkflowJobTemplatesNotificationTemplatesStartedCreateOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v2/workflow_job_templates/{id}/notification_templates_started/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Data.IsSet() {
		localVarPostBody = &localVarOptionals.Data.Value()
		
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
WorkflowJobTemplatesApiService  List Notification Templates for a Workflow Job Template
 Make a GET request to this resource to retrieve a list of notification templates associated with the selected workflow job template.  The resulting data structure contains:      {         \&quot;count\&quot;: 99,         \&quot;next\&quot;: null,         \&quot;previous\&quot;: null,         \&quot;results\&quot;: [             ...         ]     }  The &#x60;count&#x60; field indicates the total number of notification templates found for the given query.  The &#x60;next&#x60; and &#x60;previous&#x60; fields provides links to additional results if there are more than will fit on a single page.  The &#x60;results&#x60; list contains zero or more notification template records.    ## Results  Each notification template data structure includes the following fields:  * &#x60;id&#x60;: Database ID for this notification template. (integer) * &#x60;type&#x60;: Data type for this notification template. (choice) * &#x60;url&#x60;: URL for this notification template. (string) * &#x60;related&#x60;: Data structure with URLs of related resources. (object) * &#x60;summary_fields&#x60;: Data structure with name/description for related resources.  The output for some objects may be limited for performance reasons. (object) * &#x60;created&#x60;: Timestamp when this notification template was created. (datetime) * &#x60;modified&#x60;: Timestamp when this notification template was last modified. (datetime) * &#x60;name&#x60;: Name of this notification template. (string) * &#x60;description&#x60;: Optional description of this notification template. (string) * &#x60;organization&#x60;:  (id) * &#x60;notification_type&#x60;:  (choice)     - &#x60;email&#x60;: Email     - &#x60;grafana&#x60;: Grafana     - &#x60;irc&#x60;: IRC     - &#x60;mattermost&#x60;: Mattermost     - &#x60;pagerduty&#x60;: Pagerduty     - &#x60;rocketchat&#x60;: Rocket.Chat     - &#x60;slack&#x60;: Slack     - &#x60;twilio&#x60;: Twilio     - &#x60;webhook&#x60;: Webhook * &#x60;notification_configuration&#x60;:  (json) * &#x60;messages&#x60;: Optional custom messages for notification template. (json)    ## Sorting  To specify that notification templates are returned in a particular order, use the &#x60;order_by&#x60; query string parameter on the GET request.      ?order_by&#x3D;name  Prefix the field name with a dash &#x60;-&#x60; to sort in reverse:      ?order_by&#x3D;-name  Multiple sorting fields may be specified by separating the field names with a comma &#x60;,&#x60;:      ?order_by&#x3D;name,some_other_field  ## Pagination  Use the &#x60;page_size&#x60; query string parameter to change the number of results returned for each request.  Use the &#x60;page&#x60; query string parameter to retrieve a particular page of results.      ?page_size&#x3D;100&amp;page&#x3D;2  The &#x60;previous&#x60; and &#x60;next&#x60; links returned with the results will set these query string parameters automatically.  ## Searching  Use the &#x60;search&#x60; query string parameter to perform a case-insensitive search within all designated text fields of a model.      ?search&#x3D;findme  (_Added in Ansible Tower 3.1.0_) Search across related fields:      ?related__search&#x3D;findme
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id 
 * @param optional nil or *WorkflowJobTemplatesApiWorkflowJobTemplatesWorkflowJobTemplatesNotificationTemplatesStartedListOpts - Optional Parameters:
     * @param "Page" (optional.Int32) -  A page number within the paginated result set.
     * @param "PageSize" (optional.Int32) -  Number of results to return per page.
     * @param "Search" (optional.String) -  A search term.


*/

type WorkflowJobTemplatesApiWorkflowJobTemplatesWorkflowJobTemplatesNotificationTemplatesStartedListOpts struct { 
	Page optional.Int32
	PageSize optional.Int32
	Search optional.String
}

func (a *WorkflowJobTemplatesApiService) WorkflowJobTemplatesWorkflowJobTemplatesNotificationTemplatesStartedList(ctx context.Context, id string, localVarOptionals *WorkflowJobTemplatesApiWorkflowJobTemplatesWorkflowJobTemplatesNotificationTemplatesStartedListOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v2/workflow_job_templates/{id}/notification_templates_started/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Page.IsSet() {
		localVarQueryParams.Add("page", parameterToString(localVarOptionals.Page.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PageSize.IsSet() {
		localVarQueryParams.Add("page_size", parameterToString(localVarOptionals.PageSize.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Search.IsSet() {
		localVarQueryParams.Add("search", parameterToString(localVarOptionals.Search.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
WorkflowJobTemplatesApiService  Create a Notification Template for a Workflow Job Template
 Make a POST request to this resource with the following notification template fields to create a new notification template associated with this workflow job template.          * &#x60;name&#x60;: Name of this notification template. (string, required) * &#x60;description&#x60;: Optional description of this notification template. (string, default&#x3D;&#x60;\&quot;\&quot;&#x60;) * &#x60;organization&#x60;:  (id, required) * &#x60;notification_type&#x60;:  (choice, required)     - &#x60;email&#x60;: Email     - &#x60;grafana&#x60;: Grafana     - &#x60;irc&#x60;: IRC     - &#x60;mattermost&#x60;: Mattermost     - &#x60;pagerduty&#x60;: Pagerduty     - &#x60;rocketchat&#x60;: Rocket.Chat     - &#x60;slack&#x60;: Slack     - &#x60;twilio&#x60;: Twilio     - &#x60;webhook&#x60;: Webhook * &#x60;notification_configuration&#x60;:  (json, default&#x3D;&#x60;{}&#x60;) * &#x60;messages&#x60;: Optional custom messages for notification template. (json, default&#x3D;&#x60;{&amp;#39;started&amp;#39;: None, &amp;#39;success&amp;#39;: None, &amp;#39;error&amp;#39;: None, &amp;#39;workflow_approval&amp;#39;: None}&#x60;)         # Add Notification Templates for a Workflow Job Template:  Make a POST request to this resource with only an &#x60;id&#x60; field to associate an existing notification template with this workflow job template.  # Remove Notification Templates from this Workflow Job Template:  Make a POST request to this resource with &#x60;id&#x60; and &#x60;disassociate&#x60; fields to remove the notification template from this workflow job template  without deleting the notification template.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id 
 * @param optional nil or *WorkflowJobTemplatesApiWorkflowJobTemplatesWorkflowJobTemplatesNotificationTemplatesSuccessCreateOpts - Optional Parameters:
     * @param "Data" (optional.Interface of Data83) - 


*/

type WorkflowJobTemplatesApiWorkflowJobTemplatesWorkflowJobTemplatesNotificationTemplatesSuccessCreateOpts struct { 
	Data optional.Interface
}

func (a *WorkflowJobTemplatesApiService) WorkflowJobTemplatesWorkflowJobTemplatesNotificationTemplatesSuccessCreate(ctx context.Context, id string, localVarOptionals *WorkflowJobTemplatesApiWorkflowJobTemplatesWorkflowJobTemplatesNotificationTemplatesSuccessCreateOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v2/workflow_job_templates/{id}/notification_templates_success/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Data.IsSet() {
		
		localVarOptionalData, localVarOptionalDataok := localVarOptionals.Data.Value().(Data83)
		if !localVarOptionalDataok {
				return nil, reportError("data should be Data83")
		}
		localVarPostBody = &localVarOptionalData
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
WorkflowJobTemplatesApiService  List Notification Templates for a Workflow Job Template
 Make a GET request to this resource to retrieve a list of notification templates associated with the selected workflow job template.  The resulting data structure contains:      {         \&quot;count\&quot;: 99,         \&quot;next\&quot;: null,         \&quot;previous\&quot;: null,         \&quot;results\&quot;: [             ...         ]     }  The &#x60;count&#x60; field indicates the total number of notification templates found for the given query.  The &#x60;next&#x60; and &#x60;previous&#x60; fields provides links to additional results if there are more than will fit on a single page.  The &#x60;results&#x60; list contains zero or more notification template records.    ## Results  Each notification template data structure includes the following fields:  * &#x60;id&#x60;: Database ID for this notification template. (integer) * &#x60;type&#x60;: Data type for this notification template. (choice) * &#x60;url&#x60;: URL for this notification template. (string) * &#x60;related&#x60;: Data structure with URLs of related resources. (object) * &#x60;summary_fields&#x60;: Data structure with name/description for related resources.  The output for some objects may be limited for performance reasons. (object) * &#x60;created&#x60;: Timestamp when this notification template was created. (datetime) * &#x60;modified&#x60;: Timestamp when this notification template was last modified. (datetime) * &#x60;name&#x60;: Name of this notification template. (string) * &#x60;description&#x60;: Optional description of this notification template. (string) * &#x60;organization&#x60;:  (id) * &#x60;notification_type&#x60;:  (choice)     - &#x60;email&#x60;: Email     - &#x60;grafana&#x60;: Grafana     - &#x60;irc&#x60;: IRC     - &#x60;mattermost&#x60;: Mattermost     - &#x60;pagerduty&#x60;: Pagerduty     - &#x60;rocketchat&#x60;: Rocket.Chat     - &#x60;slack&#x60;: Slack     - &#x60;twilio&#x60;: Twilio     - &#x60;webhook&#x60;: Webhook * &#x60;notification_configuration&#x60;:  (json) * &#x60;messages&#x60;: Optional custom messages for notification template. (json)    ## Sorting  To specify that notification templates are returned in a particular order, use the &#x60;order_by&#x60; query string parameter on the GET request.      ?order_by&#x3D;name  Prefix the field name with a dash &#x60;-&#x60; to sort in reverse:      ?order_by&#x3D;-name  Multiple sorting fields may be specified by separating the field names with a comma &#x60;,&#x60;:      ?order_by&#x3D;name,some_other_field  ## Pagination  Use the &#x60;page_size&#x60; query string parameter to change the number of results returned for each request.  Use the &#x60;page&#x60; query string parameter to retrieve a particular page of results.      ?page_size&#x3D;100&amp;page&#x3D;2  The &#x60;previous&#x60; and &#x60;next&#x60; links returned with the results will set these query string parameters automatically.  ## Searching  Use the &#x60;search&#x60; query string parameter to perform a case-insensitive search within all designated text fields of a model.      ?search&#x3D;findme  (_Added in Ansible Tower 3.1.0_) Search across related fields:      ?related__search&#x3D;findme
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id 
 * @param optional nil or *WorkflowJobTemplatesApiWorkflowJobTemplatesWorkflowJobTemplatesNotificationTemplatesSuccessListOpts - Optional Parameters:
     * @param "Page" (optional.Int32) -  A page number within the paginated result set.
     * @param "PageSize" (optional.Int32) -  Number of results to return per page.
     * @param "Search" (optional.String) -  A search term.


*/

type WorkflowJobTemplatesApiWorkflowJobTemplatesWorkflowJobTemplatesNotificationTemplatesSuccessListOpts struct { 
	Page optional.Int32
	PageSize optional.Int32
	Search optional.String
}

func (a *WorkflowJobTemplatesApiService) WorkflowJobTemplatesWorkflowJobTemplatesNotificationTemplatesSuccessList(ctx context.Context, id string, localVarOptionals *WorkflowJobTemplatesApiWorkflowJobTemplatesWorkflowJobTemplatesNotificationTemplatesSuccessListOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v2/workflow_job_templates/{id}/notification_templates_success/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Page.IsSet() {
		localVarQueryParams.Add("page", parameterToString(localVarOptionals.Page.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PageSize.IsSet() {
		localVarQueryParams.Add("page_size", parameterToString(localVarOptionals.PageSize.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Search.IsSet() {
		localVarQueryParams.Add("search", parameterToString(localVarOptionals.Search.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
WorkflowJobTemplatesApiService  List Roles for a Workflow Job Template
 Make a GET request to this resource to retrieve a list of roles associated with the selected workflow job template.  The resulting data structure contains:      {         \&quot;count\&quot;: 99,         \&quot;next\&quot;: null,         \&quot;previous\&quot;: null,         \&quot;results\&quot;: [             ...         ]     }  The &#x60;count&#x60; field indicates the total number of roles found for the given query.  The &#x60;next&#x60; and &#x60;previous&#x60; fields provides links to additional results if there are more than will fit on a single page.  The &#x60;results&#x60; list contains zero or more role records.    ## Results  Each role data structure includes the following fields:  * &#x60;id&#x60;: Database ID for this role. (integer) * &#x60;type&#x60;: Data type for this role. (choice) * &#x60;url&#x60;: URL for this role. (string) * &#x60;related&#x60;: Data structure with URLs of related resources. (object) * &#x60;summary_fields&#x60;: Data structure with name/description for related resources.  The output for some objects may be limited for performance reasons. (object) * &#x60;name&#x60;: Name of this role. (field) * &#x60;description&#x60;: Optional description of this role. (field)    ## Sorting  To specify that roles are returned in a particular order, use the &#x60;order_by&#x60; query string parameter on the GET request.      ?order_by&#x3D;name  Prefix the field name with a dash &#x60;-&#x60; to sort in reverse:      ?order_by&#x3D;-name  Multiple sorting fields may be specified by separating the field names with a comma &#x60;,&#x60;:      ?order_by&#x3D;name,some_other_field  ## Pagination  Use the &#x60;page_size&#x60; query string parameter to change the number of results returned for each request.  Use the &#x60;page&#x60; query string parameter to retrieve a particular page of results.      ?page_size&#x3D;100&amp;page&#x3D;2  The &#x60;previous&#x60; and &#x60;next&#x60; links returned with the results will set these query string parameters automatically.  ## Searching  Use the &#x60;search&#x60; query string parameter to perform a case-insensitive search within all designated text fields of a model.      ?search&#x3D;findme  (_Added in Ansible Tower 3.1.0_) Search across related fields:      ?related__search&#x3D;findme
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id 
 * @param optional nil or *WorkflowJobTemplatesApiWorkflowJobTemplatesWorkflowJobTemplatesObjectRolesListOpts - Optional Parameters:
     * @param "Page" (optional.Int32) -  A page number within the paginated result set.
     * @param "PageSize" (optional.Int32) -  Number of results to return per page.
     * @param "Search" (optional.String) -  A search term.


*/

type WorkflowJobTemplatesApiWorkflowJobTemplatesWorkflowJobTemplatesObjectRolesListOpts struct { 
	Page optional.Int32
	PageSize optional.Int32
	Search optional.String
}

func (a *WorkflowJobTemplatesApiService) WorkflowJobTemplatesWorkflowJobTemplatesObjectRolesList(ctx context.Context, id string, localVarOptionals *WorkflowJobTemplatesApiWorkflowJobTemplatesWorkflowJobTemplatesObjectRolesListOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v2/workflow_job_templates/{id}/object_roles/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Page.IsSet() {
		localVarQueryParams.Add("page", parameterToString(localVarOptionals.Page.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PageSize.IsSet() {
		localVarQueryParams.Add("page_size", parameterToString(localVarOptionals.PageSize.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Search.IsSet() {
		localVarQueryParams.Add("search", parameterToString(localVarOptionals.Search.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
WorkflowJobTemplatesApiService  Update a Workflow Job Template
 Make a PUT or PATCH request to this resource to update this workflow job template.  The following fields may be modified:          * &#x60;name&#x60;: Name of this workflow job template. (string, required) * &#x60;description&#x60;: Optional description of this workflow job template. (string, default&#x3D;&#x60;\&quot;\&quot;&#x60;)     * &#x60;extra_vars&#x60;:  (json, default&#x3D;&#x60;&#x60;) * &#x60;organization&#x60;: The organization used to determine access to this template. (id, default&#x3D;&#x60;&#x60;) * &#x60;survey_enabled&#x60;:  (boolean, default&#x3D;&#x60;False&#x60;) * &#x60;allow_simultaneous&#x60;:  (boolean, default&#x3D;&#x60;False&#x60;) * &#x60;ask_variables_on_launch&#x60;:  (boolean, default&#x3D;&#x60;False&#x60;) * &#x60;inventory&#x60;: Inventory applied as a prompt, assuming job template prompts for inventory (id, default&#x3D;&#x60;&#x60;) * &#x60;limit&#x60;:  (string, default&#x3D;&#x60;\&quot;\&quot;&#x60;) * &#x60;scm_branch&#x60;:  (string, default&#x3D;&#x60;\&quot;\&quot;&#x60;) * &#x60;ask_inventory_on_launch&#x60;:  (boolean, default&#x3D;&#x60;False&#x60;) * &#x60;ask_scm_branch_on_launch&#x60;:  (boolean, default&#x3D;&#x60;False&#x60;) * &#x60;ask_limit_on_launch&#x60;:  (boolean, default&#x3D;&#x60;False&#x60;) * &#x60;webhook_service&#x60;: Service that webhook requests will be accepted from (choice)     - &#x60;\&quot;\&quot;&#x60;: ---------     - &#x60;github&#x60;: GitHub     - &#x60;gitlab&#x60;: GitLab * &#x60;webhook_credential&#x60;: Personal Access Token for posting back the status to the service API (id, default&#x3D;&#x60;&#x60;)         For a PATCH request, include only the fields that are being modified.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id 
 * @param optional nil or *WorkflowJobTemplatesApiWorkflowJobTemplatesWorkflowJobTemplatesPartialUpdateOpts - Optional Parameters:
     * @param "Search" (optional.String) -  A search term.
     * @param "Data" (optional.Interface{}) - 


*/

type WorkflowJobTemplatesApiWorkflowJobTemplatesWorkflowJobTemplatesPartialUpdateOpts struct { 
	Search optional.String
	Data optional.Interface{}
}

func (a *WorkflowJobTemplatesApiService) WorkflowJobTemplatesWorkflowJobTemplatesPartialUpdate(ctx context.Context, id string, localVarOptionals *WorkflowJobTemplatesApiWorkflowJobTemplatesWorkflowJobTemplatesPartialUpdateOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v2/workflow_job_templates/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Search.IsSet() {
		localVarQueryParams.Add("search", parameterToString(localVarOptionals.Search.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Data.IsSet() {
		localVarPostBody = &localVarOptionals.Data.Value()
		
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
WorkflowJobTemplatesApiService  Retrieve a Workflow Job Template
 Make GET request to this resource to retrieve a single workflow job template record containing the following fields:  * &#x60;id&#x60;: Database ID for this workflow job template. (integer) * &#x60;type&#x60;: Data type for this workflow job template. (choice) * &#x60;url&#x60;: URL for this workflow job template. (string) * &#x60;related&#x60;: Data structure with URLs of related resources. (object) * &#x60;summary_fields&#x60;: Data structure with name/description for related resources.  The output for some objects may be limited for performance reasons. (object) * &#x60;created&#x60;: Timestamp when this workflow job template was created. (datetime) * &#x60;modified&#x60;: Timestamp when this workflow job template was last modified. (datetime) * &#x60;name&#x60;: Name of this workflow job template. (string) * &#x60;description&#x60;: Optional description of this workflow job template. (string) * &#x60;last_job_run&#x60;:  (datetime) * &#x60;last_job_failed&#x60;:  (boolean) * &#x60;next_job_run&#x60;:  (datetime) * &#x60;status&#x60;:  (choice)     - &#x60;new&#x60;: New     - &#x60;pending&#x60;: Pending     - &#x60;waiting&#x60;: Waiting     - &#x60;running&#x60;: Running     - &#x60;successful&#x60;: Successful     - &#x60;failed&#x60;: Failed     - &#x60;error&#x60;: Error     - &#x60;canceled&#x60;: Canceled     - &#x60;never updated&#x60;: Never Updated     - &#x60;ok&#x60;: OK     - &#x60;missing&#x60;: Missing     - &#x60;none&#x60;: No External Source     - &#x60;updating&#x60;: Updating * &#x60;extra_vars&#x60;:  (json) * &#x60;organization&#x60;: The organization used to determine access to this template. (id) * &#x60;survey_enabled&#x60;:  (boolean) * &#x60;allow_simultaneous&#x60;:  (boolean) * &#x60;ask_variables_on_launch&#x60;:  (boolean) * &#x60;inventory&#x60;: Inventory applied as a prompt, assuming job template prompts for inventory (id) * &#x60;limit&#x60;:  (string) * &#x60;scm_branch&#x60;:  (string) * &#x60;ask_inventory_on_launch&#x60;:  (boolean) * &#x60;ask_scm_branch_on_launch&#x60;:  (boolean) * &#x60;ask_limit_on_launch&#x60;:  (boolean) * &#x60;webhook_service&#x60;: Service that webhook requests will be accepted from (choice)     - &#x60;\&quot;\&quot;&#x60;: ---------     - &#x60;github&#x60;: GitHub     - &#x60;gitlab&#x60;: GitLab * &#x60;webhook_credential&#x60;: Personal Access Token for posting back the status to the service API (id)
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id 
 * @param optional nil or *WorkflowJobTemplatesApiWorkflowJobTemplatesWorkflowJobTemplatesReadOpts - Optional Parameters:
     * @param "Search" (optional.String) -  A search term.


*/

type WorkflowJobTemplatesApiWorkflowJobTemplatesWorkflowJobTemplatesReadOpts struct { 
	Search optional.String
}

func (a *WorkflowJobTemplatesApiService) WorkflowJobTemplatesWorkflowJobTemplatesRead(ctx context.Context, id string, localVarOptionals *WorkflowJobTemplatesApiWorkflowJobTemplatesWorkflowJobTemplatesReadOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v2/workflow_job_templates/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Search.IsSet() {
		localVarQueryParams.Add("search", parameterToString(localVarOptionals.Search.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
WorkflowJobTemplatesApiService  Create a Schedule for a Workflow Job Template
 Make a POST request to this resource with the following schedule fields to create a new schedule associated with this workflow job template.   * &#x60;rrule&#x60;: A value representing the schedules iCal recurrence rule. (string, required)        * &#x60;name&#x60;: Name of this schedule. (string, required) * &#x60;description&#x60;: Optional description of this schedule. (string, default&#x3D;&#x60;\&quot;\&quot;&#x60;) * &#x60;extra_data&#x60;:  (json, default&#x3D;&#x60;{}&#x60;) * &#x60;inventory&#x60;: Inventory applied as a prompt, assuming job template prompts for inventory (id, default&#x3D;&#x60;&#x60;) * &#x60;scm_branch&#x60;:  (string, default&#x3D;&#x60;\&quot;\&quot;&#x60;) * &#x60;job_type&#x60;:  (choice)     - &#x60;None&#x60;: --------- (default)     - &#x60;\&quot;\&quot;&#x60;: ---------     - &#x60;run&#x60;: Run     - &#x60;check&#x60;: Check * &#x60;job_tags&#x60;:  (string, default&#x3D;&#x60;\&quot;\&quot;&#x60;) * &#x60;skip_tags&#x60;:  (string, default&#x3D;&#x60;\&quot;\&quot;&#x60;) * &#x60;limit&#x60;:  (string, default&#x3D;&#x60;\&quot;\&quot;&#x60;) * &#x60;diff_mode&#x60;:  (boolean, default&#x3D;&#x60;None&#x60;) * &#x60;verbosity&#x60;:  (choice)     - &#x60;None&#x60;: --------- (default)     - &#x60;0&#x60;: 0 (Normal)     - &#x60;1&#x60;: 1 (Verbose)     - &#x60;2&#x60;: 2 (More Verbose)     - &#x60;3&#x60;: 3 (Debug)     - &#x60;4&#x60;: 4 (Connection Debug)     - &#x60;5&#x60;: 5 (WinRM Debug)  * &#x60;enabled&#x60;: Enables processing of this schedule. (boolean, default&#x3D;&#x60;True&#x60;)
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id 
 * @param optional nil or *WorkflowJobTemplatesApiWorkflowJobTemplatesWorkflowJobTemplatesSchedulesCreateOpts - Optional Parameters:
     * @param "Data" (optional.Interface{}) - 


*/

type WorkflowJobTemplatesApiWorkflowJobTemplatesWorkflowJobTemplatesSchedulesCreateOpts struct { 
	Data optional.Interface{}
}

func (a *WorkflowJobTemplatesApiService) WorkflowJobTemplatesWorkflowJobTemplatesSchedulesCreate(ctx context.Context, id string, localVarOptionals *WorkflowJobTemplatesApiWorkflowJobTemplatesWorkflowJobTemplatesSchedulesCreateOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v2/workflow_job_templates/{id}/schedules/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Data.IsSet() {
		localVarPostBody = &localVarOptionals.Data.Value()
		
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
WorkflowJobTemplatesApiService  List Schedules for a Workflow Job Template
 Make a GET request to this resource to retrieve a list of schedules associated with the selected workflow job template.  The resulting data structure contains:      {         \&quot;count\&quot;: 99,         \&quot;next\&quot;: null,         \&quot;previous\&quot;: null,         \&quot;results\&quot;: [             ...         ]     }  The &#x60;count&#x60; field indicates the total number of schedules found for the given query.  The &#x60;next&#x60; and &#x60;previous&#x60; fields provides links to additional results if there are more than will fit on a single page.  The &#x60;results&#x60; list contains zero or more schedule records.    ## Results  Each schedule data structure includes the following fields:  * &#x60;rrule&#x60;: A value representing the schedules iCal recurrence rule. (string) * &#x60;id&#x60;: Database ID for this schedule. (integer) * &#x60;type&#x60;: Data type for this schedule. (choice) * &#x60;url&#x60;: URL for this schedule. (string) * &#x60;related&#x60;: Data structure with URLs of related resources. (object) * &#x60;summary_fields&#x60;: Data structure with name/description for related resources.  The output for some objects may be limited for performance reasons. (object) * &#x60;created&#x60;: Timestamp when this schedule was created. (datetime) * &#x60;modified&#x60;: Timestamp when this schedule was last modified. (datetime) * &#x60;name&#x60;: Name of this schedule. (string) * &#x60;description&#x60;: Optional description of this schedule. (string) * &#x60;extra_data&#x60;:  (json) * &#x60;inventory&#x60;: Inventory applied as a prompt, assuming job template prompts for inventory (id) * &#x60;scm_branch&#x60;:  (string) * &#x60;job_type&#x60;:  (choice)     - &#x60;None&#x60;: ---------     - &#x60;\&quot;\&quot;&#x60;: ---------     - &#x60;run&#x60;: Run     - &#x60;check&#x60;: Check * &#x60;job_tags&#x60;:  (string) * &#x60;skip_tags&#x60;:  (string) * &#x60;limit&#x60;:  (string) * &#x60;diff_mode&#x60;:  (boolean) * &#x60;verbosity&#x60;:  (choice)     - &#x60;None&#x60;: ---------     - &#x60;0&#x60;: 0 (Normal)     - &#x60;1&#x60;: 1 (Verbose)     - &#x60;2&#x60;: 2 (More Verbose)     - &#x60;3&#x60;: 3 (Debug)     - &#x60;4&#x60;: 4 (Connection Debug)     - &#x60;5&#x60;: 5 (WinRM Debug) * &#x60;unified_job_template&#x60;:  (id) * &#x60;enabled&#x60;: Enables processing of this schedule. (boolean) * &#x60;dtstart&#x60;: The first occurrence of the schedule occurs on or after this time. (datetime) * &#x60;dtend&#x60;: The last occurrence of the schedule occurs before this time, aftewards the schedule expires. (datetime) * &#x60;next_run&#x60;: The next time that the scheduled action will run. (datetime) * &#x60;timezone&#x60;:  (field) * &#x60;until&#x60;:  (field)    ## Sorting  To specify that schedules are returned in a particular order, use the &#x60;order_by&#x60; query string parameter on the GET request.      ?order_by&#x3D;name  Prefix the field name with a dash &#x60;-&#x60; to sort in reverse:      ?order_by&#x3D;-name  Multiple sorting fields may be specified by separating the field names with a comma &#x60;,&#x60;:      ?order_by&#x3D;name,some_other_field  ## Pagination  Use the &#x60;page_size&#x60; query string parameter to change the number of results returned for each request.  Use the &#x60;page&#x60; query string parameter to retrieve a particular page of results.      ?page_size&#x3D;100&amp;page&#x3D;2  The &#x60;previous&#x60; and &#x60;next&#x60; links returned with the results will set these query string parameters automatically.  ## Searching  Use the &#x60;search&#x60; query string parameter to perform a case-insensitive search within all designated text fields of a model.      ?search&#x3D;findme  (_Added in Ansible Tower 3.1.0_) Search across related fields:      ?related__search&#x3D;findme
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id 
 * @param optional nil or *WorkflowJobTemplatesApiWorkflowJobTemplatesWorkflowJobTemplatesSchedulesListOpts - Optional Parameters:
     * @param "Page" (optional.Int32) -  A page number within the paginated result set.
     * @param "PageSize" (optional.Int32) -  Number of results to return per page.
     * @param "Search" (optional.String) -  A search term.


*/

type WorkflowJobTemplatesApiWorkflowJobTemplatesWorkflowJobTemplatesSchedulesListOpts struct { 
	Page optional.Int32
	PageSize optional.Int32
	Search optional.String
}

func (a *WorkflowJobTemplatesApiService) WorkflowJobTemplatesWorkflowJobTemplatesSchedulesList(ctx context.Context, id string, localVarOptionals *WorkflowJobTemplatesApiWorkflowJobTemplatesWorkflowJobTemplatesSchedulesListOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v2/workflow_job_templates/{id}/schedules/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Page.IsSet() {
		localVarQueryParams.Add("page", parameterToString(localVarOptionals.Page.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PageSize.IsSet() {
		localVarQueryParams.Add("page_size", parameterToString(localVarOptionals.PageSize.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Search.IsSet() {
		localVarQueryParams.Add("search", parameterToString(localVarOptionals.Search.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
WorkflowJobTemplatesApiService POST requests to this resource should include the full specification for a Workflow Job Template&#39;s Survey
 Here is an example survey specification:      {         \&quot;name\&quot;: \&quot;Simple Survey\&quot;,         \&quot;description\&quot;: \&quot;Description of the simple survey\&quot;,         \&quot;spec\&quot;: [             {          \&quot;type\&quot;: \&quot;text\&quot;,          \&quot;question_name\&quot;: \&quot;example question\&quot;,          \&quot;question_description\&quot;: \&quot;What is your favorite color?\&quot;,          \&quot;variable\&quot;: \&quot;favorite_color\&quot;,          \&quot;required\&quot;: false,          \&quot;default\&quot;: \&quot;blue\&quot;             }         ]     }  &#x60;name&#x60; and &#x60;description&#x60; are required elements at the beginning of the survey specification. &#x60;spec&#x60; must be a list of survey items.  Within each survey item &#x60;type&#x60; must be one of:  * text: For survey questions expecting a textual answer * password: For survey questions expecting a password or other sensitive information * integer: For survey questions expecting a whole number answer * float: For survey questions expecting a decimal number * multiplechoice: For survey questions where one option from a list is required * multiselect: For survey questions where multiple items from a presented list can be selected  Each item must contain a &#x60;question_name&#x60; and &#x60;question_description&#x60; field that describes the survey question itself. The &#x60;variable&#x60; elements of each survey items represents the key that will be given to the playbook when the workflow job template is launched.  It will contain the value as a result of the survey.  Here is a more comprehensive example showing the various question types and their acceptable parameters:      {         \&quot;name\&quot;: \&quot;Simple\&quot;,         \&quot;description\&quot;: \&quot;Description\&quot;,         \&quot;spec\&quot;: [             {          \&quot;type\&quot;: \&quot;text\&quot;,          \&quot;question_name\&quot;: \&quot;cantbeshort\&quot;,          \&quot;question_description\&quot;: \&quot;What is a long answer\&quot;,          \&quot;variable\&quot;: \&quot;long_answer\&quot;,          \&quot;choices\&quot;: \&quot;\&quot;,          \&quot;min\&quot;: 5,          \&quot;max\&quot;: \&quot;\&quot;,          \&quot;required\&quot;: false,          \&quot;default\&quot;: \&quot;Leeloo Minai Lekarariba-Laminai-Tchai Ekbat De Sebat\&quot;             },             {          \&quot;type\&quot;: \&quot;text\&quot;,          \&quot;question_name\&quot;: \&quot;cantbelong\&quot;,          \&quot;question_description\&quot;: \&quot;What is a short answer\&quot;,          \&quot;variable\&quot;: \&quot;short_answer\&quot;,          \&quot;choices\&quot;: \&quot;\&quot;,          \&quot;min\&quot;: \&quot;\&quot;,          \&quot;max\&quot;: 7,          \&quot;required\&quot;: false,          \&quot;default\&quot;: \&quot;leeloo\&quot;             },             {          \&quot;type\&quot;: \&quot;text\&quot;,          \&quot;question_name\&quot;: \&quot;reqd\&quot;,          \&quot;question_description\&quot;: \&quot;I should be required\&quot;,          \&quot;variable\&quot;: \&quot;reqd_answer\&quot;,          \&quot;choices\&quot;: \&quot;\&quot;,          \&quot;min\&quot;: \&quot;\&quot;,          \&quot;max\&quot;: \&quot;\&quot;,          \&quot;required\&quot;: true,          \&quot;default\&quot;: \&quot;NOT OPTIONAL\&quot;             },             {          \&quot;type\&quot;: \&quot;multiplechoice\&quot;,          \&quot;question_name\&quot;: \&quot;achoice\&quot;,          \&quot;question_description\&quot;: \&quot;Need one of these\&quot;,          \&quot;variable\&quot;: \&quot;single_choice\&quot;,          \&quot;choices\&quot;: [\&quot;one\&quot;, \&quot;two\&quot;],          \&quot;min\&quot;: \&quot;\&quot;,          \&quot;max\&quot;: \&quot;\&quot;,          \&quot;required\&quot;: false,          \&quot;default\&quot;: \&quot;one\&quot;             },             {          \&quot;type\&quot;: \&quot;multiselect\&quot;,          \&quot;question_name\&quot;: \&quot;mchoice\&quot;,          \&quot;question_description\&quot;: \&quot;Can have multiples of these\&quot;,          \&quot;variable\&quot;: \&quot;multi_choice\&quot;,          \&quot;choices\&quot;: [\&quot;one\&quot;, \&quot;two\&quot;, \&quot;three\&quot;],          \&quot;min\&quot;: \&quot;\&quot;,          \&quot;max\&quot;: \&quot;\&quot;,          \&quot;required\&quot;: false,          \&quot;default\&quot;: \&quot;one\\nthree\&quot;             },             {                 \&quot;type\&quot;: \&quot;integer\&quot;,                 \&quot;question_name\&quot;: \&quot;integerchoice\&quot;,                 \&quot;question_description\&quot;: \&quot;I need an int here\&quot;,                 \&quot;variable\&quot;: \&quot;int_answer\&quot;,                 \&quot;choices\&quot;: \&quot;\&quot;,                 \&quot;min\&quot;: 1,                 \&quot;max\&quot;: 5,                 \&quot;required\&quot;: false,                 \&quot;default\&quot;: \&quot;\&quot;             },             {                 \&quot;type\&quot;: \&quot;float\&quot;,                 \&quot;question_name\&quot;: \&quot;float\&quot;,                 \&quot;question_description\&quot;: \&quot;I need a float here\&quot;,                 \&quot;variable\&quot;: \&quot;float_answer\&quot;,                 \&quot;choices\&quot;: \&quot;\&quot;,                 \&quot;min\&quot;: 2,                 \&quot;max\&quot;: 5,                 \&quot;required\&quot;: false,                 \&quot;default\&quot;: \&quot;\&quot;             }         ]     }
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id 
 * @param optional nil or *WorkflowJobTemplatesApiWorkflowJobTemplatesWorkflowJobTemplatesSurveySpecCreateOpts - Optional Parameters:
     * @param "Data" (optional.Interface{}) - 


*/

type WorkflowJobTemplatesApiWorkflowJobTemplatesWorkflowJobTemplatesSurveySpecCreateOpts struct { 
	Data optional.Interface{}
}

func (a *WorkflowJobTemplatesApiService) WorkflowJobTemplatesWorkflowJobTemplatesSurveySpecCreate(ctx context.Context, id string, localVarOptionals *WorkflowJobTemplatesApiWorkflowJobTemplatesWorkflowJobTemplatesSurveySpecCreateOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v2/workflow_job_templates/{id}/survey_spec/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Data.IsSet() {
		localVarPostBody = &localVarOptionals.Data.Value()
		
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
WorkflowJobTemplatesApiService POST requests to this resource should include the full specification for a Workflow Job Template&#39;s Survey
 Here is an example survey specification:      {         \&quot;name\&quot;: \&quot;Simple Survey\&quot;,         \&quot;description\&quot;: \&quot;Description of the simple survey\&quot;,         \&quot;spec\&quot;: [             {          \&quot;type\&quot;: \&quot;text\&quot;,          \&quot;question_name\&quot;: \&quot;example question\&quot;,          \&quot;question_description\&quot;: \&quot;What is your favorite color?\&quot;,          \&quot;variable\&quot;: \&quot;favorite_color\&quot;,          \&quot;required\&quot;: false,          \&quot;default\&quot;: \&quot;blue\&quot;             }         ]     }  &#x60;name&#x60; and &#x60;description&#x60; are required elements at the beginning of the survey specification. &#x60;spec&#x60; must be a list of survey items.  Within each survey item &#x60;type&#x60; must be one of:  * text: For survey questions expecting a textual answer * password: For survey questions expecting a password or other sensitive information * integer: For survey questions expecting a whole number answer * float: For survey questions expecting a decimal number * multiplechoice: For survey questions where one option from a list is required * multiselect: For survey questions where multiple items from a presented list can be selected  Each item must contain a &#x60;question_name&#x60; and &#x60;question_description&#x60; field that describes the survey question itself. The &#x60;variable&#x60; elements of each survey items represents the key that will be given to the playbook when the workflow job template is launched.  It will contain the value as a result of the survey.  Here is a more comprehensive example showing the various question types and their acceptable parameters:      {         \&quot;name\&quot;: \&quot;Simple\&quot;,         \&quot;description\&quot;: \&quot;Description\&quot;,         \&quot;spec\&quot;: [             {          \&quot;type\&quot;: \&quot;text\&quot;,          \&quot;question_name\&quot;: \&quot;cantbeshort\&quot;,          \&quot;question_description\&quot;: \&quot;What is a long answer\&quot;,          \&quot;variable\&quot;: \&quot;long_answer\&quot;,          \&quot;choices\&quot;: \&quot;\&quot;,          \&quot;min\&quot;: 5,          \&quot;max\&quot;: \&quot;\&quot;,          \&quot;required\&quot;: false,          \&quot;default\&quot;: \&quot;Leeloo Minai Lekarariba-Laminai-Tchai Ekbat De Sebat\&quot;             },             {          \&quot;type\&quot;: \&quot;text\&quot;,          \&quot;question_name\&quot;: \&quot;cantbelong\&quot;,          \&quot;question_description\&quot;: \&quot;What is a short answer\&quot;,          \&quot;variable\&quot;: \&quot;short_answer\&quot;,          \&quot;choices\&quot;: \&quot;\&quot;,          \&quot;min\&quot;: \&quot;\&quot;,          \&quot;max\&quot;: 7,          \&quot;required\&quot;: false,          \&quot;default\&quot;: \&quot;leeloo\&quot;             },             {          \&quot;type\&quot;: \&quot;text\&quot;,          \&quot;question_name\&quot;: \&quot;reqd\&quot;,          \&quot;question_description\&quot;: \&quot;I should be required\&quot;,          \&quot;variable\&quot;: \&quot;reqd_answer\&quot;,          \&quot;choices\&quot;: \&quot;\&quot;,          \&quot;min\&quot;: \&quot;\&quot;,          \&quot;max\&quot;: \&quot;\&quot;,          \&quot;required\&quot;: true,          \&quot;default\&quot;: \&quot;NOT OPTIONAL\&quot;             },             {          \&quot;type\&quot;: \&quot;multiplechoice\&quot;,          \&quot;question_name\&quot;: \&quot;achoice\&quot;,          \&quot;question_description\&quot;: \&quot;Need one of these\&quot;,          \&quot;variable\&quot;: \&quot;single_choice\&quot;,          \&quot;choices\&quot;: [\&quot;one\&quot;, \&quot;two\&quot;],          \&quot;min\&quot;: \&quot;\&quot;,          \&quot;max\&quot;: \&quot;\&quot;,          \&quot;required\&quot;: false,          \&quot;default\&quot;: \&quot;one\&quot;             },             {          \&quot;type\&quot;: \&quot;multiselect\&quot;,          \&quot;question_name\&quot;: \&quot;mchoice\&quot;,          \&quot;question_description\&quot;: \&quot;Can have multiples of these\&quot;,          \&quot;variable\&quot;: \&quot;multi_choice\&quot;,          \&quot;choices\&quot;: [\&quot;one\&quot;, \&quot;two\&quot;, \&quot;three\&quot;],          \&quot;min\&quot;: \&quot;\&quot;,          \&quot;max\&quot;: \&quot;\&quot;,          \&quot;required\&quot;: false,          \&quot;default\&quot;: \&quot;one\\nthree\&quot;             },             {                 \&quot;type\&quot;: \&quot;integer\&quot;,                 \&quot;question_name\&quot;: \&quot;integerchoice\&quot;,                 \&quot;question_description\&quot;: \&quot;I need an int here\&quot;,                 \&quot;variable\&quot;: \&quot;int_answer\&quot;,                 \&quot;choices\&quot;: \&quot;\&quot;,                 \&quot;min\&quot;: 1,                 \&quot;max\&quot;: 5,                 \&quot;required\&quot;: false,                 \&quot;default\&quot;: \&quot;\&quot;             },             {                 \&quot;type\&quot;: \&quot;float\&quot;,                 \&quot;question_name\&quot;: \&quot;float\&quot;,                 \&quot;question_description\&quot;: \&quot;I need a float here\&quot;,                 \&quot;variable\&quot;: \&quot;float_answer\&quot;,                 \&quot;choices\&quot;: \&quot;\&quot;,                 \&quot;min\&quot;: 2,                 \&quot;max\&quot;: 5,                 \&quot;required\&quot;: false,                 \&quot;default\&quot;: \&quot;\&quot;             }         ]     }
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id 
 * @param optional nil or *WorkflowJobTemplatesApiWorkflowJobTemplatesWorkflowJobTemplatesSurveySpecDeleteOpts - Optional Parameters:
     * @param "Search" (optional.String) -  A search term.


*/

type WorkflowJobTemplatesApiWorkflowJobTemplatesWorkflowJobTemplatesSurveySpecDeleteOpts struct { 
	Search optional.String
}

func (a *WorkflowJobTemplatesApiService) WorkflowJobTemplatesWorkflowJobTemplatesSurveySpecDelete(ctx context.Context, id string, localVarOptionals *WorkflowJobTemplatesApiWorkflowJobTemplatesWorkflowJobTemplatesSurveySpecDeleteOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v2/workflow_job_templates/{id}/survey_spec/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Search.IsSet() {
		localVarQueryParams.Add("search", parameterToString(localVarOptionals.Search.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
WorkflowJobTemplatesApiService POST requests to this resource should include the full specification for a Workflow Job Template&#39;s Survey
 Here is an example survey specification:      {         \&quot;name\&quot;: \&quot;Simple Survey\&quot;,         \&quot;description\&quot;: \&quot;Description of the simple survey\&quot;,         \&quot;spec\&quot;: [             {          \&quot;type\&quot;: \&quot;text\&quot;,          \&quot;question_name\&quot;: \&quot;example question\&quot;,          \&quot;question_description\&quot;: \&quot;What is your favorite color?\&quot;,          \&quot;variable\&quot;: \&quot;favorite_color\&quot;,          \&quot;required\&quot;: false,          \&quot;default\&quot;: \&quot;blue\&quot;             }         ]     }  &#x60;name&#x60; and &#x60;description&#x60; are required elements at the beginning of the survey specification. &#x60;spec&#x60; must be a list of survey items.  Within each survey item &#x60;type&#x60; must be one of:  * text: For survey questions expecting a textual answer * password: For survey questions expecting a password or other sensitive information * integer: For survey questions expecting a whole number answer * float: For survey questions expecting a decimal number * multiplechoice: For survey questions where one option from a list is required * multiselect: For survey questions where multiple items from a presented list can be selected  Each item must contain a &#x60;question_name&#x60; and &#x60;question_description&#x60; field that describes the survey question itself. The &#x60;variable&#x60; elements of each survey items represents the key that will be given to the playbook when the workflow job template is launched.  It will contain the value as a result of the survey.  Here is a more comprehensive example showing the various question types and their acceptable parameters:      {         \&quot;name\&quot;: \&quot;Simple\&quot;,         \&quot;description\&quot;: \&quot;Description\&quot;,         \&quot;spec\&quot;: [             {          \&quot;type\&quot;: \&quot;text\&quot;,          \&quot;question_name\&quot;: \&quot;cantbeshort\&quot;,          \&quot;question_description\&quot;: \&quot;What is a long answer\&quot;,          \&quot;variable\&quot;: \&quot;long_answer\&quot;,          \&quot;choices\&quot;: \&quot;\&quot;,          \&quot;min\&quot;: 5,          \&quot;max\&quot;: \&quot;\&quot;,          \&quot;required\&quot;: false,          \&quot;default\&quot;: \&quot;Leeloo Minai Lekarariba-Laminai-Tchai Ekbat De Sebat\&quot;             },             {          \&quot;type\&quot;: \&quot;text\&quot;,          \&quot;question_name\&quot;: \&quot;cantbelong\&quot;,          \&quot;question_description\&quot;: \&quot;What is a short answer\&quot;,          \&quot;variable\&quot;: \&quot;short_answer\&quot;,          \&quot;choices\&quot;: \&quot;\&quot;,          \&quot;min\&quot;: \&quot;\&quot;,          \&quot;max\&quot;: 7,          \&quot;required\&quot;: false,          \&quot;default\&quot;: \&quot;leeloo\&quot;             },             {          \&quot;type\&quot;: \&quot;text\&quot;,          \&quot;question_name\&quot;: \&quot;reqd\&quot;,          \&quot;question_description\&quot;: \&quot;I should be required\&quot;,          \&quot;variable\&quot;: \&quot;reqd_answer\&quot;,          \&quot;choices\&quot;: \&quot;\&quot;,          \&quot;min\&quot;: \&quot;\&quot;,          \&quot;max\&quot;: \&quot;\&quot;,          \&quot;required\&quot;: true,          \&quot;default\&quot;: \&quot;NOT OPTIONAL\&quot;             },             {          \&quot;type\&quot;: \&quot;multiplechoice\&quot;,          \&quot;question_name\&quot;: \&quot;achoice\&quot;,          \&quot;question_description\&quot;: \&quot;Need one of these\&quot;,          \&quot;variable\&quot;: \&quot;single_choice\&quot;,          \&quot;choices\&quot;: [\&quot;one\&quot;, \&quot;two\&quot;],          \&quot;min\&quot;: \&quot;\&quot;,          \&quot;max\&quot;: \&quot;\&quot;,          \&quot;required\&quot;: false,          \&quot;default\&quot;: \&quot;one\&quot;             },             {          \&quot;type\&quot;: \&quot;multiselect\&quot;,          \&quot;question_name\&quot;: \&quot;mchoice\&quot;,          \&quot;question_description\&quot;: \&quot;Can have multiples of these\&quot;,          \&quot;variable\&quot;: \&quot;multi_choice\&quot;,          \&quot;choices\&quot;: [\&quot;one\&quot;, \&quot;two\&quot;, \&quot;three\&quot;],          \&quot;min\&quot;: \&quot;\&quot;,          \&quot;max\&quot;: \&quot;\&quot;,          \&quot;required\&quot;: false,          \&quot;default\&quot;: \&quot;one\\nthree\&quot;             },             {                 \&quot;type\&quot;: \&quot;integer\&quot;,                 \&quot;question_name\&quot;: \&quot;integerchoice\&quot;,                 \&quot;question_description\&quot;: \&quot;I need an int here\&quot;,                 \&quot;variable\&quot;: \&quot;int_answer\&quot;,                 \&quot;choices\&quot;: \&quot;\&quot;,                 \&quot;min\&quot;: 1,                 \&quot;max\&quot;: 5,                 \&quot;required\&quot;: false,                 \&quot;default\&quot;: \&quot;\&quot;             },             {                 \&quot;type\&quot;: \&quot;float\&quot;,                 \&quot;question_name\&quot;: \&quot;float\&quot;,                 \&quot;question_description\&quot;: \&quot;I need a float here\&quot;,                 \&quot;variable\&quot;: \&quot;float_answer\&quot;,                 \&quot;choices\&quot;: \&quot;\&quot;,                 \&quot;min\&quot;: 2,                 \&quot;max\&quot;: 5,                 \&quot;required\&quot;: false,                 \&quot;default\&quot;: \&quot;\&quot;             }         ]     }
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id 
 * @param optional nil or *WorkflowJobTemplatesApiWorkflowJobTemplatesWorkflowJobTemplatesSurveySpecListOpts - Optional Parameters:
     * @param "Page" (optional.Int32) -  A page number within the paginated result set.
     * @param "PageSize" (optional.Int32) -  Number of results to return per page.
     * @param "Search" (optional.String) -  A search term.


*/

type WorkflowJobTemplatesApiWorkflowJobTemplatesWorkflowJobTemplatesSurveySpecListOpts struct { 
	Page optional.Int32
	PageSize optional.Int32
	Search optional.String
}

func (a *WorkflowJobTemplatesApiService) WorkflowJobTemplatesWorkflowJobTemplatesSurveySpecList(ctx context.Context, id string, localVarOptionals *WorkflowJobTemplatesApiWorkflowJobTemplatesWorkflowJobTemplatesSurveySpecListOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v2/workflow_job_templates/{id}/survey_spec/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Page.IsSet() {
		localVarQueryParams.Add("page", parameterToString(localVarOptionals.Page.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PageSize.IsSet() {
		localVarQueryParams.Add("page_size", parameterToString(localVarOptionals.PageSize.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Search.IsSet() {
		localVarQueryParams.Add("search", parameterToString(localVarOptionals.Search.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
WorkflowJobTemplatesApiService  Update a Workflow Job Template
 Make a PUT or PATCH request to this resource to update this workflow job template.  The following fields may be modified:          * &#x60;name&#x60;: Name of this workflow job template. (string, required) * &#x60;description&#x60;: Optional description of this workflow job template. (string, default&#x3D;&#x60;\&quot;\&quot;&#x60;)     * &#x60;extra_vars&#x60;:  (json, default&#x3D;&#x60;&#x60;) * &#x60;organization&#x60;: The organization used to determine access to this template. (id, default&#x3D;&#x60;&#x60;) * &#x60;survey_enabled&#x60;:  (boolean, default&#x3D;&#x60;False&#x60;) * &#x60;allow_simultaneous&#x60;:  (boolean, default&#x3D;&#x60;False&#x60;) * &#x60;ask_variables_on_launch&#x60;:  (boolean, default&#x3D;&#x60;False&#x60;) * &#x60;inventory&#x60;: Inventory applied as a prompt, assuming job template prompts for inventory (id, default&#x3D;&#x60;&#x60;) * &#x60;limit&#x60;:  (string, default&#x3D;&#x60;\&quot;\&quot;&#x60;) * &#x60;scm_branch&#x60;:  (string, default&#x3D;&#x60;\&quot;\&quot;&#x60;) * &#x60;ask_inventory_on_launch&#x60;:  (boolean, default&#x3D;&#x60;False&#x60;) * &#x60;ask_scm_branch_on_launch&#x60;:  (boolean, default&#x3D;&#x60;False&#x60;) * &#x60;ask_limit_on_launch&#x60;:  (boolean, default&#x3D;&#x60;False&#x60;) * &#x60;webhook_service&#x60;: Service that webhook requests will be accepted from (choice)     - &#x60;\&quot;\&quot;&#x60;: ---------     - &#x60;github&#x60;: GitHub     - &#x60;gitlab&#x60;: GitLab * &#x60;webhook_credential&#x60;: Personal Access Token for posting back the status to the service API (id, default&#x3D;&#x60;&#x60;)       For a PUT request, include **all** fields in the request.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id 
 * @param optional nil or *WorkflowJobTemplatesApiWorkflowJobTemplatesWorkflowJobTemplatesUpdateOpts - Optional Parameters:
     * @param "Search" (optional.String) -  A search term.
     * @param "Data" (optional.Interface of Data78) - 


*/

type WorkflowJobTemplatesApiWorkflowJobTemplatesWorkflowJobTemplatesUpdateOpts struct { 
	Search optional.String
	Data optional.Interface
}

func (a *WorkflowJobTemplatesApiService) WorkflowJobTemplatesWorkflowJobTemplatesUpdate(ctx context.Context, id string, localVarOptionals *WorkflowJobTemplatesApiWorkflowJobTemplatesWorkflowJobTemplatesUpdateOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v2/workflow_job_templates/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Search.IsSet() {
		localVarQueryParams.Add("search", parameterToString(localVarOptionals.Search.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Data.IsSet() {
		
		localVarOptionalData, localVarOptionalDataok := localVarOptionals.Data.Value().(Data78)
		if !localVarOptionalDataok {
				return nil, reportError("data should be Data78")
		}
		localVarPostBody = &localVarOptionalData
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
WorkflowJobTemplatesApiService
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id 


*/
func (a *WorkflowJobTemplatesApiService) WorkflowJobTemplatesWorkflowJobTemplatesWebhookKeyCreate(ctx context.Context, id string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v2/workflow_job_templates/{id}/webhook_key/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
WorkflowJobTemplatesApiService
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id 
 * @param optional nil or *WorkflowJobTemplatesApiWorkflowJobTemplatesWorkflowJobTemplatesWebhookKeyListOpts - Optional Parameters:
     * @param "Page" (optional.Int32) -  A page number within the paginated result set.
     * @param "PageSize" (optional.Int32) -  Number of results to return per page.
     * @param "Search" (optional.String) -  A search term.


*/

type WorkflowJobTemplatesApiWorkflowJobTemplatesWorkflowJobTemplatesWebhookKeyListOpts struct { 
	Page optional.Int32
	PageSize optional.Int32
	Search optional.String
}

func (a *WorkflowJobTemplatesApiService) WorkflowJobTemplatesWorkflowJobTemplatesWebhookKeyList(ctx context.Context, id string, localVarOptionals *WorkflowJobTemplatesApiWorkflowJobTemplatesWorkflowJobTemplatesWebhookKeyListOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v2/workflow_job_templates/{id}/webhook_key/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Page.IsSet() {
		localVarQueryParams.Add("page", parameterToString(localVarOptionals.Page.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PageSize.IsSet() {
		localVarQueryParams.Add("page_size", parameterToString(localVarOptionals.PageSize.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Search.IsSet() {
		localVarQueryParams.Add("search", parameterToString(localVarOptionals.Search.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
WorkflowJobTemplatesApiService  List Workflow Jobs for a Workflow Job Template
 Make a GET request to this resource to retrieve a list of workflow jobs associated with the selected workflow job template.  The resulting data structure contains:      {         \&quot;count\&quot;: 99,         \&quot;next\&quot;: null,         \&quot;previous\&quot;: null,         \&quot;results\&quot;: [             ...         ]     }  The &#x60;count&#x60; field indicates the total number of workflow jobs found for the given query.  The &#x60;next&#x60; and &#x60;previous&#x60; fields provides links to additional results if there are more than will fit on a single page.  The &#x60;results&#x60; list contains zero or more workflow job records.    ## Results  Each workflow job data structure includes the following fields:  * &#x60;id&#x60;: Database ID for this workflow job. (integer) * &#x60;type&#x60;: Data type for this workflow job. (choice) * &#x60;url&#x60;: URL for this workflow job. (string) * &#x60;related&#x60;: Data structure with URLs of related resources. (object) * &#x60;summary_fields&#x60;: Data structure with name/description for related resources.  The output for some objects may be limited for performance reasons. (object) * &#x60;created&#x60;: Timestamp when this workflow job was created. (datetime) * &#x60;modified&#x60;: Timestamp when this workflow job was last modified. (datetime) * &#x60;name&#x60;: Name of this workflow job. (string) * &#x60;description&#x60;: Optional description of this workflow job. (string) * &#x60;unified_job_template&#x60;:  (id) * &#x60;launch_type&#x60;:  (choice)     - &#x60;manual&#x60;: Manual     - &#x60;relaunch&#x60;: Relaunch     - &#x60;callback&#x60;: Callback     - &#x60;scheduled&#x60;: Scheduled     - &#x60;dependency&#x60;: Dependency     - &#x60;workflow&#x60;: Workflow     - &#x60;webhook&#x60;: Webhook     - &#x60;sync&#x60;: Sync     - &#x60;scm&#x60;: SCM Update * &#x60;status&#x60;:  (choice)     - &#x60;new&#x60;: New     - &#x60;pending&#x60;: Pending     - &#x60;waiting&#x60;: Waiting     - &#x60;running&#x60;: Running     - &#x60;successful&#x60;: Successful     - &#x60;failed&#x60;: Failed     - &#x60;error&#x60;: Error     - &#x60;canceled&#x60;: Canceled * &#x60;failed&#x60;:  (boolean) * &#x60;started&#x60;: The date and time the job was queued for starting. (datetime) * &#x60;finished&#x60;: The date and time the job finished execution. (datetime) * &#x60;canceled_on&#x60;: The date and time when the cancel request was sent. (datetime) * &#x60;elapsed&#x60;: Elapsed time in seconds that the job ran. (decimal) * &#x60;job_explanation&#x60;: A status field to indicate the state of the job if it wasn&amp;#39;t able to run and capture stdout (string) * &#x60;launched_by&#x60;:  (field) * &#x60;work_unit_id&#x60;: The Receptor work unit ID associated with this job. (string) * &#x60;workflow_job_template&#x60;:  (id) * &#x60;extra_vars&#x60;:  (json) * &#x60;allow_simultaneous&#x60;:  (boolean) * &#x60;job_template&#x60;: If automatically created for a sliced job run, the job template the workflow job was created from. (id) * &#x60;is_sliced_job&#x60;:  (boolean) * &#x60;inventory&#x60;: Inventory applied as a prompt, assuming job template prompts for inventory (id) * &#x60;limit&#x60;:  (string) * &#x60;scm_branch&#x60;:  (string) * &#x60;webhook_service&#x60;: Service that webhook requests will be accepted from (choice)     - &#x60;\&quot;\&quot;&#x60;: ---------     - &#x60;github&#x60;: GitHub     - &#x60;gitlab&#x60;: GitLab * &#x60;webhook_credential&#x60;: Personal Access Token for posting back the status to the service API (id) * &#x60;webhook_guid&#x60;: Unique identifier of the event that triggered this webhook (string)    ## Sorting  To specify that workflow jobs are returned in a particular order, use the &#x60;order_by&#x60; query string parameter on the GET request.      ?order_by&#x3D;name  Prefix the field name with a dash &#x60;-&#x60; to sort in reverse:      ?order_by&#x3D;-name  Multiple sorting fields may be specified by separating the field names with a comma &#x60;,&#x60;:      ?order_by&#x3D;name,some_other_field  ## Pagination  Use the &#x60;page_size&#x60; query string parameter to change the number of results returned for each request.  Use the &#x60;page&#x60; query string parameter to retrieve a particular page of results.      ?page_size&#x3D;100&amp;page&#x3D;2  The &#x60;previous&#x60; and &#x60;next&#x60; links returned with the results will set these query string parameters automatically.  ## Searching  Use the &#x60;search&#x60; query string parameter to perform a case-insensitive search within all designated text fields of a model.      ?search&#x3D;findme  (_Added in Ansible Tower 3.1.0_) Search across related fields:      ?related__search&#x3D;findme
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id 
 * @param optional nil or *WorkflowJobTemplatesApiWorkflowJobTemplatesWorkflowJobTemplatesWorkflowJobsListOpts - Optional Parameters:
     * @param "Page" (optional.Int32) -  A page number within the paginated result set.
     * @param "PageSize" (optional.Int32) -  Number of results to return per page.
     * @param "Search" (optional.String) -  A search term.


*/

type WorkflowJobTemplatesApiWorkflowJobTemplatesWorkflowJobTemplatesWorkflowJobsListOpts struct { 
	Page optional.Int32
	PageSize optional.Int32
	Search optional.String
}

func (a *WorkflowJobTemplatesApiService) WorkflowJobTemplatesWorkflowJobTemplatesWorkflowJobsList(ctx context.Context, id string, localVarOptionals *WorkflowJobTemplatesApiWorkflowJobTemplatesWorkflowJobTemplatesWorkflowJobsListOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v2/workflow_job_templates/{id}/workflow_jobs/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Page.IsSet() {
		localVarQueryParams.Add("page", parameterToString(localVarOptionals.Page.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PageSize.IsSet() {
		localVarQueryParams.Add("page_size", parameterToString(localVarOptionals.PageSize.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Search.IsSet() {
		localVarQueryParams.Add("search", parameterToString(localVarOptionals.Search.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
WorkflowJobTemplatesApiService  Workflow Job Template Workflow Node List
 Workflow nodes reference templates to execute and define the ordering in which to execute them. After a job in this workflow finishes, the subsequent actions are to:   - run nodes contained in \&quot;failure_nodes\&quot; or \&quot;always_nodes\&quot; if job failed  - run nodes contained in \&quot;success_nodes\&quot; or \&quot;always_nodes\&quot; if job succeeded  The workflow job is marked as &#x60;successful&#x60; if all of the jobs running as a part of the workflow job have completed, and the workflow job has not been canceled. Even if a job within the workflow has failed, the workflow job will not be marked as failed.     # Create a Workflow Job Template Node for a Workflow Job Template:  Make a POST request to this resource with the following workflow job template node fields to create a new workflow job template node associated with this workflow job template.          * &#x60;extra_data&#x60;:  (json, default&#x3D;&#x60;{}&#x60;) * &#x60;inventory&#x60;: Inventory applied as a prompt, assuming job template prompts for inventory (id, default&#x3D;&#x60;&#x60;) * &#x60;scm_branch&#x60;:  (string, default&#x3D;&#x60;\&quot;\&quot;&#x60;) * &#x60;job_type&#x60;:  (choice)     - &#x60;None&#x60;: --------- (default)     - &#x60;\&quot;\&quot;&#x60;: ---------     - &#x60;run&#x60;: Run     - &#x60;check&#x60;: Check * &#x60;job_tags&#x60;:  (string, default&#x3D;&#x60;\&quot;\&quot;&#x60;) * &#x60;skip_tags&#x60;:  (string, default&#x3D;&#x60;\&quot;\&quot;&#x60;) * &#x60;limit&#x60;:  (string, default&#x3D;&#x60;\&quot;\&quot;&#x60;) * &#x60;diff_mode&#x60;:  (boolean, default&#x3D;&#x60;None&#x60;) * &#x60;verbosity&#x60;:  (choice)     - &#x60;None&#x60;: --------- (default)     - &#x60;0&#x60;: 0 (Normal)     - &#x60;1&#x60;: 1 (Verbose)     - &#x60;2&#x60;: 2 (More Verbose)     - &#x60;3&#x60;: 3 (Debug)     - &#x60;4&#x60;: 4 (Connection Debug)     - &#x60;5&#x60;: 5 (WinRM Debug)  * &#x60;unified_job_template&#x60;:  (id, default&#x3D;&#x60;&#x60;)    * &#x60;all_parents_must_converge&#x60;: If enabled then the node will only run if all of the parent nodes have met the criteria to reach this node (boolean, default&#x3D;&#x60;False&#x60;) * &#x60;identifier&#x60;: An identifier for this node that is unique within its workflow. It is copied to workflow job nodes corresponding to this node. (string, default&#x3D;&#x60;\&quot;xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx\&quot;&#x60;)
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id 
 * @param optional nil or *WorkflowJobTemplatesApiWorkflowJobTemplatesWorkflowJobTemplatesWorkflowNodesCreateOpts - Optional Parameters:
     * @param "Data" (optional.Interface{}) - 


*/

type WorkflowJobTemplatesApiWorkflowJobTemplatesWorkflowJobTemplatesWorkflowNodesCreateOpts struct { 
	Data optional.Interface{}
}

func (a *WorkflowJobTemplatesApiService) WorkflowJobTemplatesWorkflowJobTemplatesWorkflowNodesCreate(ctx context.Context, id string, localVarOptionals *WorkflowJobTemplatesApiWorkflowJobTemplatesWorkflowJobTemplatesWorkflowNodesCreateOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v2/workflow_job_templates/{id}/workflow_nodes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Data.IsSet() {
		localVarPostBody = &localVarOptionals.Data.Value()
		
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
WorkflowJobTemplatesApiService  Workflow Job Template Workflow Node List
 Workflow nodes reference templates to execute and define the ordering in which to execute them. After a job in this workflow finishes, the subsequent actions are to:   - run nodes contained in \&quot;failure_nodes\&quot; or \&quot;always_nodes\&quot; if job failed  - run nodes contained in \&quot;success_nodes\&quot; or \&quot;always_nodes\&quot; if job succeeded  The workflow job is marked as &#x60;successful&#x60; if all of the jobs running as a part of the workflow job have completed, and the workflow job has not been canceled. Even if a job within the workflow has failed, the workflow job will not be marked as failed.   # List Workflow Job Template Nodes for a Workflow Job Template:  Make a GET request to this resource to retrieve a list of workflow job template nodes associated with the selected workflow job template.  The resulting data structure contains:      {         \&quot;count\&quot;: 99,         \&quot;next\&quot;: null,         \&quot;previous\&quot;: null,         \&quot;results\&quot;: [             ...         ]     }  The &#x60;count&#x60; field indicates the total number of workflow job template nodes found for the given query.  The &#x60;next&#x60; and &#x60;previous&#x60; fields provides links to additional results if there are more than will fit on a single page.  The &#x60;results&#x60; list contains zero or more workflow job template node records.    ## Results  Each workflow job template node data structure includes the following fields:  * &#x60;id&#x60;: Database ID for this workflow job template node. (integer) * &#x60;type&#x60;: Data type for this workflow job template node. (choice) * &#x60;url&#x60;: URL for this workflow job template node. (string) * &#x60;related&#x60;: Data structure with URLs of related resources. (object) * &#x60;summary_fields&#x60;: Data structure with name/description for related resources.  The output for some objects may be limited for performance reasons. (object) * &#x60;created&#x60;: Timestamp when this workflow job template node was created. (datetime) * &#x60;modified&#x60;: Timestamp when this workflow job template node was last modified. (datetime) * &#x60;extra_data&#x60;:  (json) * &#x60;inventory&#x60;: Inventory applied as a prompt, assuming job template prompts for inventory (id) * &#x60;scm_branch&#x60;:  (string) * &#x60;job_type&#x60;:  (choice)     - &#x60;None&#x60;: ---------     - &#x60;\&quot;\&quot;&#x60;: ---------     - &#x60;run&#x60;: Run     - &#x60;check&#x60;: Check * &#x60;job_tags&#x60;:  (string) * &#x60;skip_tags&#x60;:  (string) * &#x60;limit&#x60;:  (string) * &#x60;diff_mode&#x60;:  (boolean) * &#x60;verbosity&#x60;:  (choice)     - &#x60;None&#x60;: ---------     - &#x60;0&#x60;: 0 (Normal)     - &#x60;1&#x60;: 1 (Verbose)     - &#x60;2&#x60;: 2 (More Verbose)     - &#x60;3&#x60;: 3 (Debug)     - &#x60;4&#x60;: 4 (Connection Debug)     - &#x60;5&#x60;: 5 (WinRM Debug) * &#x60;workflow_job_template&#x60;:  (id) * &#x60;unified_job_template&#x60;:  (id) * &#x60;success_nodes&#x60;:  (field) * &#x60;failure_nodes&#x60;:  (field) * &#x60;always_nodes&#x60;:  (field) * &#x60;all_parents_must_converge&#x60;: If enabled then the node will only run if all of the parent nodes have met the criteria to reach this node (boolean) * &#x60;identifier&#x60;: An identifier for this node that is unique within its workflow. It is copied to workflow job nodes corresponding to this node. (string)    ## Sorting  To specify that workflow job template nodes are returned in a particular order, use the &#x60;order_by&#x60; query string parameter on the GET request.      ?order_by&#x3D;name  Prefix the field name with a dash &#x60;-&#x60; to sort in reverse:      ?order_by&#x3D;-name  Multiple sorting fields may be specified by separating the field names with a comma &#x60;,&#x60;:      ?order_by&#x3D;name,some_other_field  ## Pagination  Use the &#x60;page_size&#x60; query string parameter to change the number of results returned for each request.  Use the &#x60;page&#x60; query string parameter to retrieve a particular page of results.      ?page_size&#x3D;100&amp;page&#x3D;2  The &#x60;previous&#x60; and &#x60;next&#x60; links returned with the results will set these query string parameters automatically.  ## Searching  Use the &#x60;search&#x60; query string parameter to perform a case-insensitive search within all designated text fields of a model.      ?search&#x3D;findme  (_Added in Ansible Tower 3.1.0_) Search across related fields:      ?related__search&#x3D;findme
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id 
 * @param optional nil or *WorkflowJobTemplatesApiWorkflowJobTemplatesWorkflowJobTemplatesWorkflowNodesListOpts - Optional Parameters:
     * @param "Page" (optional.Int32) -  A page number within the paginated result set.
     * @param "PageSize" (optional.Int32) -  Number of results to return per page.
     * @param "Search" (optional.String) -  A search term.


*/

type WorkflowJobTemplatesApiWorkflowJobTemplatesWorkflowJobTemplatesWorkflowNodesListOpts struct { 
	Page optional.Int32
	PageSize optional.Int32
	Search optional.String
}

func (a *WorkflowJobTemplatesApiService) WorkflowJobTemplatesWorkflowJobTemplatesWorkflowNodesList(ctx context.Context, id string, localVarOptionals *WorkflowJobTemplatesApiWorkflowJobTemplatesWorkflowJobTemplatesWorkflowNodesListOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v2/workflow_job_templates/{id}/workflow_nodes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Page.IsSet() {
		localVarQueryParams.Add("page", parameterToString(localVarOptionals.Page.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PageSize.IsSet() {
		localVarQueryParams.Add("page_size", parameterToString(localVarOptionals.PageSize.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Search.IsSet() {
		localVarQueryParams.Add("search", parameterToString(localVarOptionals.Search.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

